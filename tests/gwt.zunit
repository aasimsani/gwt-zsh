#!/usr/bin/env zunit

# =============================================================================
# Error Handling Tests
# =============================================================================

@test 'Returns error when not in git repo' {
    local test_dir=$(mktemp -d)
    mkdir -p "$test_dir/not-a-repo"
    cd "$test_dir/not-a-repo"

    run gwt some-branch

    assert $state equals 1
    rm -rf "$test_dir"
}

@test 'Shows correct error message for non-repo' {
    local test_dir=$(mktemp -d)
    mkdir -p "$test_dir/not-a-repo"
    cd "$test_dir/not-a-repo"

    run gwt some-branch

    assert "$output" contains "Not in a git repository"
    rm -rf "$test_dir"
}

@test 'Returns error when no branch provided' {
    create_test_repo

    run gwt

    assert $state equals 1
    cleanup_test_repo
}

@test 'Shows usage when no branch provided' {
    create_test_repo

    run gwt

    assert "$output" contains "Usage: gwt"
    cleanup_test_repo
}

# =============================================================================
# Linear Ticket Extraction Tests
# =============================================================================

@test 'Extracts eng-XXXX from standard Linear branch' {
    local ticket=$(echo "aasim/eng-1045-allow-changing-user-types" | grep -oE 'eng-[0-9]+' | head -1)

    assert "$ticket" same_as "eng-1045"
}

@test 'Extracts first eng-XXXX when multiple present' {
    local ticket=$(echo "fix/eng-123-and-eng-456-related" | grep -oE 'eng-[0-9]+' | head -1)

    assert "$ticket" same_as "eng-123"
}

@test 'Handles large ticket numbers' {
    local ticket=$(echo "user/eng-99999-big-ticket" | grep -oE 'eng-[0-9]+' | head -1)

    assert "$ticket" same_as "eng-99999"
}

@test 'Extracts from deeply nested prefixes' {
    local ticket=$(echo "team/user/eng-6000-deep" | grep -oE 'eng-[0-9]+' | head -1)

    assert "$ticket" same_as "eng-6000"
}

# =============================================================================
# Regular Branch Name Extraction Tests
# =============================================================================

@test 'Extracts first 3 words from regular branch' {
    local name=$(echo "feature/add-new-dashboard-components-extra" | sed 's|^[^/]*/||' | tr '-' '\n' | head -3 | tr '\n' '-' | sed 's/-$//')

    assert "$name" same_as "add-new-dashboard"
}

@test 'Handles branch with fewer than 3 words' {
    local name=$(echo "fix/quick-patch" | sed 's|^[^/]*/||' | tr '-' '\n' | head -3 | tr '\n' '-' | sed 's/-$//')

    assert "$name" same_as "quick-patch"
}

@test 'Strips common prefixes' {
    local name=$(echo "hotfix/urgent-security-fix-now" | sed 's|^[^/]*/||' | tr '-' '\n' | head -3 | tr '\n' '-' | sed 's/-$//')

    assert "$name" same_as "urgent-security-fix"
}

# =============================================================================
# Worktree Path Construction Tests
# =============================================================================

@test 'Constructs correct path for Linear branch' {
    create_test_repo

    run gwt aasim/eng-1045-test-branch

    assert "$output" contains "test-repo-eng-1045"
    cleanup_test_repo
}

@test 'Constructs correct path for regular branch' {
    create_test_repo

    run gwt feature/add-new-thing-here

    assert "$output" contains "test-repo-add-new-thing"
    cleanup_test_repo
}

# =============================================================================
# Worktree Creation Tests
# =============================================================================

@test 'Creates new worktree successfully' {
    create_test_repo

    run gwt test/eng-3000-new-feature

    assert $state equals 0
    cleanup_test_repo
}

@test 'Shows success message' {
    create_test_repo

    run gwt test/eng-3001-success-msg

    assert "$output" contains "Worktree created successfully"
    cleanup_test_repo
}

@test 'Worktree directory exists after creation' {
    create_test_repo
    local expected_path="$PARENT_DIR/test-repo-eng-3002"

    gwt test/eng-3002-dir-exists >/dev/null 2>&1

    assert "$expected_path" is_dir
    cleanup_test_repo
}

@test 'Worktree is on correct branch' {
    create_test_repo

    gwt test/eng-4000-branch-check >/dev/null 2>&1
    cd "$PARENT_DIR/test-repo-eng-4000"
    local current_branch=$(git rev-parse --abbrev-ref HEAD)

    assert "$current_branch" same_as "test/eng-4000-branch-check"
    cleanup_test_repo
}

# =============================================================================
# Existing Worktree Handling Tests
# =============================================================================

@test 'Returns success for existing worktree' {
    create_test_repo
    local worktree_path="$PARENT_DIR/test-repo-eng-2000"
    git worktree add -q -b test/eng-2000-exists "$worktree_path" HEAD

    run gwt test/eng-2000-exists

    assert $state equals 0
    cleanup_test_repo
}

@test 'Detects existing worktree' {
    create_test_repo
    local worktree_path="$PARENT_DIR/test-repo-eng-2001"
    git worktree add -q -b test/eng-2001-exists "$worktree_path" HEAD

    run gwt test/eng-2001-exists

    assert "$output" contains "Worktree already exists"
    cleanup_test_repo
}

@test 'Shows cd message for existing worktree' {
    create_test_repo
    local worktree_path="$PARENT_DIR/test-repo-eng-2002"
    git worktree add -q -b test/eng-2002-exists "$worktree_path" HEAD

    run gwt test/eng-2002-exists

    assert "$output" contains "Changing to existing worktree"
    cleanup_test_repo
}

# =============================================================================
# Copy Config Dirs Flag Tests
# =============================================================================

@test '--copy-config-dirs flag creates worktree successfully' {
    create_test_repo
    mkdir -p serena
    echo "config" > serena/config.yml

    run gwt --copy-config-dirs serena test/eng-5000-copy-test

    assert $state equals 0
    cleanup_test_repo
}

@test '--copy-config-dirs flag copies config dir to worktree' {
    create_test_repo
    mkdir -p serena
    echo "config" > serena/config.yml

    gwt --copy-config-dirs serena test/eng-5000-copy-test2 >/dev/null 2>&1

    assert "$PARENT_DIR/test-repo-eng-5000/serena" is_dir
    cleanup_test_repo
}

@test '--copy-config-dirs flag handles multiple dirs' {
    create_test_repo
    mkdir -p serena .vscode
    echo "config" > serena/config.yml
    echo "settings" > .vscode/settings.json

    run gwt --copy-config-dirs serena --copy-config-dirs .vscode test/eng-5001-multi-copy

    assert $state equals 0
    cleanup_test_repo
}

@test '--copy-config-dirs flag copies first dir' {
    create_test_repo
    mkdir -p serena .vscode
    echo "config" > serena/config.yml
    echo "settings" > .vscode/settings.json

    gwt --copy-config-dirs serena --copy-config-dirs .vscode test/eng-5001-multi-copy2 >/dev/null 2>&1

    assert "$PARENT_DIR/test-repo-eng-5001/serena" is_dir
    cleanup_test_repo
}

@test '--copy-config-dirs flag copies second dir' {
    create_test_repo
    mkdir -p serena .vscode
    echo "config" > serena/config.yml
    echo "settings" > .vscode/settings.json

    gwt --copy-config-dirs serena --copy-config-dirs .vscode test/eng-5001-multi-copy3 >/dev/null 2>&1

    assert "$PARENT_DIR/test-repo-eng-5001/.vscode" is_dir
    cleanup_test_repo
}

# =============================================================================
# GWT_COPY_DIRS Env Var Tests
# =============================================================================

@test 'GWT_COPY_DIRS env var creates worktree successfully' {
    create_test_repo
    mkdir -p serena
    echo "config" > serena/config.yml
    export GWT_COPY_DIRS="serena"

    run gwt test/eng-5002-env-test

    assert $state equals 0
    unset GWT_COPY_DIRS
    cleanup_test_repo
}

@test 'GWT_COPY_DIRS env var copies config dir' {
    create_test_repo
    mkdir -p serena
    echo "config" > serena/config.yml
    export GWT_COPY_DIRS="serena"

    gwt test/eng-5002-env-test2 >/dev/null 2>&1

    assert "$PARENT_DIR/test-repo-eng-5002/serena" is_dir
    unset GWT_COPY_DIRS
    cleanup_test_repo
}

@test 'GWT_COPY_DIRS env var handles multiple dirs' {
    create_test_repo
    mkdir -p serena .vscode
    echo "config" > serena/config.yml
    echo "settings" > .vscode/settings.json
    export GWT_COPY_DIRS="serena,.vscode"

    run gwt test/eng-5003-env-multi

    assert $state equals 0
    unset GWT_COPY_DIRS
    cleanup_test_repo
}

@test 'GWT_COPY_DIRS env var copies first dir from list' {
    create_test_repo
    mkdir -p serena .vscode
    echo "config" > serena/config.yml
    echo "settings" > .vscode/settings.json
    export GWT_COPY_DIRS="serena,.vscode"

    gwt test/eng-5003-env-multi2 >/dev/null 2>&1

    assert "$PARENT_DIR/test-repo-eng-5003/serena" is_dir
    unset GWT_COPY_DIRS
    cleanup_test_repo
}

@test 'GWT_COPY_DIRS env var copies second dir from list' {
    create_test_repo
    mkdir -p serena .vscode
    echo "config" > serena/config.yml
    echo "settings" > .vscode/settings.json
    export GWT_COPY_DIRS="serena,.vscode"

    gwt test/eng-5003-env-multi3 >/dev/null 2>&1

    assert "$PARENT_DIR/test-repo-eng-5003/.vscode" is_dir
    unset GWT_COPY_DIRS
    cleanup_test_repo
}

# =============================================================================
# Copy Config Dirs Warning Tests
# =============================================================================

@test 'Non-existent dir still creates worktree successfully' {
    create_test_repo

    run gwt --copy-config-dirs nonexistent test/eng-5004-warn-test

    assert $state equals 0
    cleanup_test_repo
}

@test 'Non-existent dir shows warning message' {
    create_test_repo

    run gwt --copy-config-dirs nonexistent test/eng-5004-warn-test2

    assert "$output" contains "Warning"
    cleanup_test_repo
}

@test 'Non-existent dir warning mentions directory name' {
    create_test_repo

    run gwt --copy-config-dirs nonexistent test/eng-5004-warn-test3

    assert "$output" contains "nonexistent"
    cleanup_test_repo
}

# =============================================================================
# Config Command Tests
# =============================================================================

@test 'gwt --config works outside git repo' {
    local test_dir=$(mktemp -d)
    mkdir -p "$test_dir/not-a-repo"
    cd "$test_dir/not-a-repo"

    run gwt --config --help

    assert $state equals 0
    rm -rf "$test_dir"
}

@test 'gwt --config shows config help' {
    local test_dir=$(mktemp -d)
    mkdir -p "$test_dir/not-a-repo"
    cd "$test_dir/not-a-repo"

    run gwt --config --help

    assert "$output" contains "config"
    rm -rf "$test_dir"
}

@test '_gwt_config_read extracts dirs from zshrc' {
    local test_dir=$(mktemp -d)
    local test_zshrc="$test_dir/test_zshrc"
    echo 'export GWT_COPY_DIRS="serena,.vscode"' > "$test_zshrc"

    local result=$(_gwt_config_read "$test_zshrc")

    assert "$result" same_as "serena,.vscode"
    rm -rf "$test_dir"
}

@test '_gwt_config_read returns empty when no config' {
    local test_dir=$(mktemp -d)
    local test_zshrc="$test_dir/test_zshrc"
    echo '# just a comment' > "$test_zshrc"

    local result=$(_gwt_config_read "$test_zshrc")

    assert "$result" is_empty
    rm -rf "$test_dir"
}

@test '_gwt_config_write adds config to file' {
    local test_dir=$(mktemp -d)
    local test_zshrc="$test_dir/test_zshrc"
    echo '# my zshrc' > "$test_zshrc"

    _gwt_config_write "$test_zshrc" "serena"

    assert "$(cat "$test_zshrc")" contains 'export GWT_COPY_DIRS="serena"'
    rm -rf "$test_dir"
}

@test '_gwt_config_write replaces existing without duplicates' {
    local test_dir=$(mktemp -d)
    local test_zshrc="$test_dir/test_zshrc"
    echo 'export GWT_COPY_DIRS="old"' > "$test_zshrc"

    _gwt_config_write "$test_zshrc" "serena,.vscode"
    local count=$(grep -c 'GWT_COPY_DIRS' "$test_zshrc")

    assert "$count" equals 1
    rm -rf "$test_dir"
}

@test '_gwt_config_write updates with new value' {
    local test_dir=$(mktemp -d)
    local test_zshrc="$test_dir/test_zshrc"
    echo 'export GWT_COPY_DIRS="old"' > "$test_zshrc"

    _gwt_config_write "$test_zshrc" "serena,.vscode"

    assert "$(cat "$test_zshrc")" contains 'export GWT_COPY_DIRS="serena,.vscode"'
    rm -rf "$test_dir"
}

@test '_gwt_config_write removes line when value is empty' {
    local test_dir=$(mktemp -d)
    local test_zshrc="$test_dir/test_zshrc"
    echo 'export GWT_COPY_DIRS="serena"' > "$test_zshrc"

    _gwt_config_write "$test_zshrc" ""
    local content=$(cat "$test_zshrc")

    assert "$content" does_not_contain "GWT_COPY_DIRS"
    rm -rf "$test_dir"
}

# =============================================================================
# Version and Update Tests
# =============================================================================

@test 'gwt --version shows version' {
    run gwt --version

    assert $state equals 0
    assert "$output" contains "gwt version"
}

@test 'gwt --version works outside git repo' {
    local test_dir=$(mktemp -d)
    mkdir -p "$test_dir/not-a-repo"
    cd "$test_dir/not-a-repo"

    run gwt --version

    assert $state equals 0
    assert "$output" contains "gwt version"
    rm -rf "$test_dir"
}

@test 'gwt --update runs update check' {
    run gwt --update

    # Should either succeed (if installed via git) or fail gracefully
    # Output should show it attempted to update
    assert "$output" contains "gwt"
}

# =============================================================================
# Security Tests
# =============================================================================

@test '_gwt_validate_dir accepts simple name' {
    run _gwt_validate_dir "serena"

    assert $state equals 0
}

@test '_gwt_validate_dir accepts dotfile' {
    run _gwt_validate_dir ".vscode"

    assert $state equals 0
}

@test '_gwt_validate_dir accepts relative path' {
    run _gwt_validate_dir "path/to/dir"

    assert $state equals 0
}

@test '_gwt_validate_dir rejects path traversal' {
    run _gwt_validate_dir "../etc"

    assert $state equals 1
}

@test '_gwt_validate_dir rejects absolute path' {
    run _gwt_validate_dir "/etc/passwd"

    assert $state equals 1
}

@test '_gwt_validate_dir rejects semicolon' {
    run _gwt_validate_dir "foo;rm"

    assert $state equals 1
}

@test '_gwt_validate_dir rejects pipe' {
    run _gwt_validate_dir "foo|bar"

    assert $state equals 1
}

@test '_gwt_validate_dir rejects empty string' {
    run _gwt_validate_dir ""

    assert $state equals 1
}

@test 'Security: rejects path traversal in --copy-config-dirs' {
    create_test_repo

    run gwt --copy-config-dirs "../../../etc" test/eng-6000-traversal

    assert $state equals 1
    cleanup_test_repo
}

@test 'Security: shows error for path traversal' {
    create_test_repo

    run gwt --copy-config-dirs "../../../etc" test/eng-6000-traversal2

    assert "$output" contains "Invalid directory"
    cleanup_test_repo
}

@test 'Security: rejects absolute paths' {
    create_test_repo

    run gwt --copy-config-dirs "/etc/passwd" test/eng-6001-absolute

    assert $state equals 1
    cleanup_test_repo
}

@test 'Security: shows error for absolute path' {
    create_test_repo

    run gwt --copy-config-dirs "/etc/passwd" test/eng-6001-absolute2

    assert "$output" contains "Invalid directory"
    cleanup_test_repo
}

@test 'Security: rejects shell metacharacters' {
    create_test_repo

    run gwt --copy-config-dirs 'foo;rm -rf /' test/eng-6002-injection

    assert $state equals 1
    cleanup_test_repo
}

@test 'Security: shows error for metacharacters' {
    create_test_repo

    run gwt --copy-config-dirs 'foo;rm -rf /' test/eng-6002-injection2

    assert "$output" contains "Invalid directory"
    cleanup_test_repo
}

@test 'Security: config write sanitizes quotes' {
    local test_dir=$(mktemp -d)
    local test_zshrc="$test_dir/test_zshrc"
    echo '# test' > "$test_zshrc"

    _gwt_config_write "$test_zshrc" 'serena"; echo "pwned'
    local content=$(cat "$test_zshrc")

    # Verify quotes were sanitized (pwned should not appear or be escaped)
    assert "$content" does_not_contain "pwned"
    rm -rf "$test_dir"
}

@test 'Security: no git push/remote operations' {
    create_test_repo
    # Safety: Use TEST_DIR which is verified to be in temp
    local git_log="$TEST_DIR/gwt_git_log"

    # Create a mock git that logs all commands
    mkdir -p "$TEST_DIR/bin"
    echo '#!/bin/zsh
echo "$@" >> '"$git_log"'
/usr/bin/git "$@"' > "$TEST_DIR/bin/git"
    chmod +x "$TEST_DIR/bin/git"

    PATH="$TEST_DIR/bin:$PATH" gwt test/eng-6003-security >/dev/null 2>&1

    local has_forbidden=false
    if [[ -f "$git_log" ]]; then
        # Check for forbidden git operations (word boundaries with \b)
        if grep -qE '\b(push|clone)\b|remote add' "$git_log" 2>/dev/null; then
            has_forbidden=true
        fi
        # git_log is inside TEST_DIR, cleaned up by cleanup_test_repo
    fi

    assert "$has_forbidden" same_as "false"
    cleanup_test_repo
}

# =============================================================================
# --list Flag Tests
# =============================================================================

@test 'gwt --list requires git repo' {
    local test_dir=$(mktemp -d)
    mkdir -p "$test_dir/not-a-repo"
    cd "$test_dir/not-a-repo"

    run gwt --list

    assert $state equals 1
    assert "$output" contains "Not in a git repository"
    rm -rf "$test_dir"
}

@test 'gwt --list shows message when no worktrees' {
    create_test_repo

    run gwt --list

    assert $state equals 0
    assert "$output" contains "No worktrees"
    cleanup_test_repo
}

@test 'gwt --list shows worktrees when they exist' {
    create_test_repo
    local worktree_path="$PARENT_DIR/test-repo-eng-7000"
    git worktree add -q -b test/eng-7000-list "$worktree_path" HEAD

    run gwt --list

    assert $state equals 0
    assert "$output" contains "test-repo-eng-7000"
    cleanup_test_repo
}

@test 'gwt --list shows branch name' {
    create_test_repo
    local worktree_path="$PARENT_DIR/test-repo-eng-7001"
    git worktree add -q -b test/eng-7001-list-branch "$worktree_path" HEAD

    run gwt --list

    assert "$output" contains "test/eng-7001-list-branch"
    cleanup_test_repo
}

# =============================================================================
# --list-copy-dirs Flag Tests
# =============================================================================

@test 'gwt --list-copy-dirs shows message when no config' {
    # Clear any existing config and use empty test zshrc
    unset GWT_COPY_DIRS
    local test_dir=$(mktemp -d)
    local test_zshrc="$test_dir/test_zshrc"
    echo '# empty' > "$test_zshrc"

    # Override HOME to use test zshrc
    HOME="$test_dir" run gwt --list-copy-dirs

    assert $state equals 0
    assert "$output" contains "No directories configured"
    rm -rf "$test_dir"
}

@test 'gwt --list-copy-dirs shows configured dirs' {
    local test_dir=$(mktemp -d)
    local test_zshrc="$test_dir/.zshrc"
    echo 'export GWT_COPY_DIRS="serena,.vscode"' > "$test_zshrc"

    HOME="$test_dir" run gwt --list-copy-dirs

    assert $state equals 0
    assert "$output" contains "serena"
    assert "$output" contains ".vscode"
    rm -rf "$test_dir"
}

@test 'gwt --list-copy-dirs works outside git repo' {
    local test_dir=$(mktemp -d)
    mkdir -p "$test_dir/not-a-repo"
    cd "$test_dir/not-a-repo"

    run gwt --list-copy-dirs

    assert $state equals 0
    rm -rf "$test_dir"
}

# =============================================================================
# --prune Flag Tests
# =============================================================================

@test 'gwt --prune requires git repo' {
    local test_dir=$(mktemp -d)
    mkdir -p "$test_dir/not-a-repo"
    cd "$test_dir/not-a-repo"

    run gwt --prune

    assert $state equals 1
    assert "$output" contains "Not in a git repository"
    rm -rf "$test_dir"
}

@test 'gwt --prune shows message when no worktrees' {
    create_test_repo

    run gwt --prune

    assert $state equals 0
    assert "$output" contains "No worktrees to prune"
    cleanup_test_repo
}

@test 'gwt --prune shows worktrees for selection' {
    create_test_repo
    local worktree_path="$PARENT_DIR/test-repo-eng-8000"
    git worktree add -q -b test/eng-8000-prune "$worktree_path" HEAD

    # Send 'q' to quit immediately using here-string
    run gwt --prune <<< "q"

    assert $state equals 0
    assert "$output" contains "test-repo-eng-8000"
    cleanup_test_repo
}

# =============================================================================
# Cycle 1: Security Enhancement - Regex Escaping Tests
# =============================================================================

@test 'Security: config remove handles dot in directory name correctly' {
    # This tests the regex escaping fix for line 266
    # Without escaping, "foo.bar" could match "fooXbar" due to regex wildcard
    local test_dir=$(mktemp -d)
    local test_zshrc="$test_dir/.zshrc"
    echo 'export GWT_COPY_DIRS="foo.bar,fooXbar,other"' > "$test_zshrc"

    # Simulate the _gwt_config menu: choice 2 (remove), enter "foo.bar", choice 4 (done)
    HOME="$test_dir" run _gwt_config <<< $'2\nfoo.bar\n4'

    # Read the resulting config
    local result=$(_gwt_config_read "$test_zshrc")

    # fooXbar should still be present (not incorrectly matched by foo.bar pattern)
    assert "$result" contains "fooXbar"
    assert "$result" contains "other"
    # foo.bar should be removed
    assert "$result" does_not_contain "foo.bar"
    rm -rf "$test_dir"
}

# =============================================================================
# Cycle 2: Additional Security Validation Tests
# =============================================================================

@test '_gwt_validate_dir rejects backticks' {
    run _gwt_validate_dir '`rm -rf /`'

    assert $state equals 1
}

@test '_gwt_validate_dir rejects dollar sign' {
    run _gwt_validate_dir '$(rm -rf /)'

    assert $state equals 1
}

@test '_gwt_validate_dir rejects newlines' {
    run _gwt_validate_dir $'foo\nbar'

    assert $state equals 1
}

@test '_gwt_validate_dir rejects spaces' {
    run _gwt_validate_dir 'foo bar'

    assert $state equals 1
}

@test '_gwt_validate_dir rejects backslash' {
    run _gwt_validate_dir 'foo\\bar'

    assert $state equals 1
}

@test '_gwt_validate_dir rejects ampersand' {
    run _gwt_validate_dir 'foo&bar'

    assert $state equals 1
}

@test 'Security: GWT_COPY_DIRS with malicious content is filtered' {
    create_test_repo
    mkdir -p serena
    echo "config" > serena/config.yml
    # Attempt to inject malicious dirs via env var
    export GWT_COPY_DIRS="../../../etc,serena,/etc/passwd"

    run gwt test/eng-9001-env-security

    # Should succeed (malicious dirs filtered out, serena is valid)
    assert $state equals 0
    unset GWT_COPY_DIRS
    cleanup_test_repo
}

@test 'Security: config write sanitizes backticks' {
    local test_dir=$(mktemp -d)
    local test_zshrc="$test_dir/test_zshrc"
    echo '# test' > "$test_zshrc"

    _gwt_config_write "$test_zshrc" 'serena`whoami`'
    local content=$(cat "$test_zshrc")

    # Verify backticks were sanitized
    assert "$content" does_not_contain "\`"
    rm -rf "$test_dir"
}

@test 'Security: config write sanitizes dollar signs' {
    local test_dir=$(mktemp -d)
    local test_zshrc="$test_dir/test_zshrc"
    echo '# test' > "$test_zshrc"

    _gwt_config_write "$test_zshrc" 'serena$(whoami)'
    local content=$(cat "$test_zshrc")

    # Verify dollar signs were sanitized
    assert "$content" does_not_contain "\$"
    rm -rf "$test_dir"
}

# =============================================================================
# Cycle 3: _gwt_update() Tests
# =============================================================================

@test '_gwt_update shows error when install dir not found' {
    # Temporarily unset install dir and set to nonexistent
    # Also override HOME to prevent fallback paths from matching
    local old_install="$GWT_INSTALL_DIR"
    local test_dir=$(mktemp -d)
    GWT_INSTALL_DIR="/nonexistent/path/gwt"

    HOME="$test_dir" run _gwt_update

    assert $state equals 1
    assert "$output" contains "Could not find"
    GWT_INSTALL_DIR="$old_install"
    rm -rf "$test_dir"
}

@test '_gwt_update shows error when not a git repo' {
    local test_dir=$(mktemp -d)
    local old_install="$GWT_INSTALL_DIR"
    GWT_INSTALL_DIR="$test_dir"

    run _gwt_update

    assert $state equals 1
    assert "$output" contains "not a git repository"
    GWT_INSTALL_DIR="$old_install"
    rm -rf "$test_dir"
}

@test '_gwt_update shows already up to date when at HEAD' {
    # Use the actual gwt installation which is a git repo
    run _gwt_update

    # Should either show "up to date" or "Updating"
    assert $state equals 0
}

# =============================================================================
# Cycle 4: _gwt_config() Interactive Tests
# =============================================================================

@test '_gwt_config add directory to empty config' {
    local test_dir=$(mktemp -d)
    local test_zshrc="$test_dir/.zshrc"
    echo '# empty' > "$test_zshrc"

    # Menu: 1 (add), enter "serena", 4 (done)
    HOME="$test_dir" run _gwt_config <<< $'1\nserena\n4'

    local result=$(_gwt_config_read "$test_zshrc")
    assert "$result" same_as "serena"
    rm -rf "$test_dir"
}

@test '_gwt_config add directory to existing config' {
    local test_dir=$(mktemp -d)
    local test_zshrc="$test_dir/.zshrc"
    echo 'export GWT_COPY_DIRS="existing"' > "$test_zshrc"

    # Menu: 1 (add), enter "newdir", 4 (done)
    HOME="$test_dir" run _gwt_config <<< $'1\nnewdir\n4'

    local result=$(_gwt_config_read "$test_zshrc")
    assert "$result" contains "existing"
    assert "$result" contains "newdir"
    rm -rf "$test_dir"
}

@test '_gwt_config detects duplicate directory' {
    local test_dir=$(mktemp -d)
    local test_zshrc="$test_dir/.zshrc"
    echo 'export GWT_COPY_DIRS="serena"' > "$test_zshrc"

    # Menu: 1 (add), enter "serena" (duplicate), 4 (done)
    HOME="$test_dir" run _gwt_config <<< $'1\nserena\n4'

    assert "$output" contains "already configured"
    rm -rf "$test_dir"
}

@test '_gwt_config remove directory from config' {
    local test_dir=$(mktemp -d)
    local test_zshrc="$test_dir/.zshrc"
    echo 'export GWT_COPY_DIRS="serena,vscode"' > "$test_zshrc"

    # Menu: 2 (remove), enter "serena", 4 (done)
    HOME="$test_dir" run _gwt_config <<< $'2\nserena\n4'

    local result=$(_gwt_config_read "$test_zshrc")
    assert "$result" same_as "vscode"
    rm -rf "$test_dir"
}

@test '_gwt_config remove from empty shows message' {
    local test_dir=$(mktemp -d)
    local test_zshrc="$test_dir/.zshrc"
    echo '# empty' > "$test_zshrc"

    # Menu: 2 (remove), 4 (done)
    HOME="$test_dir" run _gwt_config <<< $'2\n4'

    assert "$output" contains "No directories to remove"
    rm -rf "$test_dir"
}

@test '_gwt_config list shows directories' {
    local test_dir=$(mktemp -d)
    local test_zshrc="$test_dir/.zshrc"
    echo 'export GWT_COPY_DIRS="serena,vscode"' > "$test_zshrc"

    # Menu: 3 (list), 4 (done)
    HOME="$test_dir" run _gwt_config <<< $'3\n4'

    assert "$output" contains "serena"
    assert "$output" contains "vscode"
    rm -rf "$test_dir"
}

@test '_gwt_config list empty shows no dirs message' {
    local test_dir=$(mktemp -d)
    local test_zshrc="$test_dir/.zshrc"
    echo '# empty' > "$test_zshrc"

    # Menu: 3 (list), 4 (done)
    HOME="$test_dir" run _gwt_config <<< $'3\n4'

    assert "$output" contains "No directories configured"
    rm -rf "$test_dir"
}

@test '_gwt_config invalid choice shows error' {
    local test_dir=$(mktemp -d)
    local test_zshrc="$test_dir/.zshrc"
    echo '# empty' > "$test_zshrc"

    # Menu: 9 (invalid), 4 (done)
    HOME="$test_dir" run _gwt_config <<< $'9\n4'

    assert "$output" contains "Invalid choice"
    rm -rf "$test_dir"
}

# =============================================================================
# Cycle 5: _gwt_prune() Tests
# =============================================================================

@test 'gwt --prune fallback selection with specific number' {
    create_test_repo
    local worktree_path="$PARENT_DIR/test-repo-eng-8100"
    git worktree add -q -b test/eng-8100-prune-num "$worktree_path" HEAD

    # Select worktree 1, then cancel at first confirmation
    run gwt --prune <<< $'1\nn'

    assert $state equals 0
    assert "$output" contains "Cancelled"
    cleanup_test_repo
}

@test 'gwt --prune fallback selection with all' {
    create_test_repo
    local worktree_path="$PARENT_DIR/test-repo-eng-8101"
    git worktree add -q -b test/eng-8101-prune-all "$worktree_path" HEAD

    # Select 'all', then cancel at first confirmation
    run gwt --prune <<< $'all\nn'

    assert $state equals 0
    assert "$output" contains "Cancelled"
    cleanup_test_repo
}

@test 'gwt --prune shows uncommitted changes warning' {
    create_test_repo
    local worktree_path="$PARENT_DIR/test-repo-eng-8102"
    git worktree add -q -b test/eng-8102-uncommitted "$worktree_path" HEAD

    # Create uncommitted change in worktree
    echo "uncommitted" > "$worktree_path/uncommitted.txt"

    # Select worktree 1, then cancel
    run gwt --prune <<< $'1\nn'

    assert "$output" contains "WARNING"
    assert "$output" contains "Uncommitted"
    cleanup_test_repo
}

@test 'gwt --prune cancels on first confirmation' {
    create_test_repo
    local worktree_path="$PARENT_DIR/test-repo-eng-8103"
    git worktree add -q -b test/eng-8103-cancel1 "$worktree_path" HEAD

    # Select worktree 1, then 'n' at first confirmation
    run gwt --prune <<< $'1\nn'

    assert $state equals 0
    assert "$output" contains "Cancelled"
    # Worktree should still exist
    assert "$worktree_path" is_dir
    cleanup_test_repo
}

@test 'gwt --prune cancels on DELETE confirmation' {
    create_test_repo
    local worktree_path="$PARENT_DIR/test-repo-eng-8104"
    git worktree add -q -b test/eng-8104-cancel2 "$worktree_path" HEAD

    # Select worktree 1, 'y' at first confirmation, then wrong text
    run gwt --prune <<< $'1\ny\nwrong'

    assert $state equals 0
    assert "$output" contains "Cancelled"
    # Worktree should still exist
    assert "$worktree_path" is_dir
    cleanup_test_repo
}

@test 'gwt --prune deletes worktree on full confirmation' {
    create_test_repo
    local worktree_path="$PARENT_DIR/test-repo-eng-8105"
    git worktree add -q -b test/eng-8105-delete "$worktree_path" HEAD

    # Select worktree 1, 'y', then 'DELETE'
    run gwt --prune <<< $'1\ny\nDELETE'

    assert $state equals 0
    assert "$output" contains "Done"
    # Worktree should be removed (check that it does NOT exist)
    [[ ! -d "$worktree_path" ]]
    assert $? equals 0
    cleanup_test_repo
}

# =============================================================================
# Cycle 6: gwt() Edge Case Tests
# =============================================================================

@test 'gwt rejects unknown option' {
    create_test_repo

    run gwt --unknown-flag

    assert $state equals 1
    assert "$output" contains "Unknown option"
    cleanup_test_repo
}

@test 'gwt --copy-config-dirs without argument shows error' {
    create_test_repo

    run gwt --copy-config-dirs

    assert $state equals 1
    assert "$output" contains "requires"
    cleanup_test_repo
}

@test 'gwt uses local branch when exists' {
    create_test_repo
    # Create a local branch
    git branch test/eng-9000-local

    run gwt test/eng-9000-local

    assert $state equals 0
    assert "$output" contains "Worktree created"
    cleanup_test_repo
}

@test 'gwt creates new branch when not found' {
    create_test_repo

    run gwt test/eng-9010-newbranch

    assert $state equals 0
    assert "$output" contains "Worktree created"
    # Verify the branch was created
    local wt_path="$PARENT_DIR/test-repo-eng-9010"
    local branch=$(cd "$wt_path" && git branch --show-current)
    assert "$branch" same_as "test/eng-9010-newbranch"
    cleanup_test_repo
}

@test 'gwt handles branch with slash prefix correctly' {
    create_test_repo

    run gwt feature/add-user-auth-flow

    assert $state equals 0
    # Should extract 3 words after prefix
    assert "$output" contains "test-repo-add-user-auth"
    cleanup_test_repo
}

# =============================================================================
# Cycle 7: _gwt_print() Helper Tests
# =============================================================================

@test '_gwt_print outputs message' {
    run _gwt_print "Test message"

    assert $state equals 0
    assert "$output" contains "Test message"
}

@test '_gwt_print outputs message with color' {
    run _gwt_print "Colored message" "green"

    assert $state equals 0
    assert "$output" contains "Colored message"
}

@test '_gwt_print outputs message with prefix symbol' {
    run _gwt_print "Symbol message" "green" "✓"

    assert $state equals 0
    assert "$output" contains "Symbol message"
    assert "$output" contains "✓"
}

# =============================================================================
# --help Flag Tests
# =============================================================================

@test 'gwt --help shows help message' {
    run gwt --help

    assert $state equals 0
    assert "$output" contains "Usage:"
    assert "$output" contains "Options:"
    assert "$output" contains "GWT_COPY_DIRS"
}

@test 'gwt -h shows help message' {
    run gwt -h

    assert $state equals 0
    assert "$output" contains "Usage:"
}

@test 'gwt --help works outside git repo' {
    local test_dir=$(mktemp -d)
    mkdir -p "$test_dir/not-a-repo"
    cd "$test_dir/not-a-repo"

    run gwt --help

    assert $state equals 0
    assert "$output" contains "gwt - Git Worktree helper"
    rm -rf "$test_dir"
}
