#!/usr/bin/env zunit

# =============================================================================
# Error Handling Tests
# =============================================================================

@test 'Returns error when not in git repo' {
    local test_dir=$(mktemp -d)
    mkdir -p "$test_dir/not-a-repo"
    cd "$test_dir/not-a-repo"

    run gwt some-branch

    assert $state equals 1
    rm -rf "$test_dir"
}

@test 'Shows correct error message for non-repo' {
    local test_dir=$(mktemp -d)
    mkdir -p "$test_dir/not-a-repo"
    cd "$test_dir/not-a-repo"

    run gwt some-branch

    assert "$output" contains "Not in a git repository"
    rm -rf "$test_dir"
}

@test 'Returns error when no branch provided' {
    create_test_repo

    run gwt

    assert $state equals 1
    cleanup_test_repo
}

@test 'Shows usage when no branch provided' {
    create_test_repo

    run gwt

    assert "$output" contains "Usage: gwt"
    cleanup_test_repo
}

# =============================================================================
# Linear Ticket Extraction Tests
# =============================================================================

@test 'Extracts eng-XXXX from standard Linear branch' {
    local ticket=$(echo "aasim/eng-1045-allow-changing-user-types" | grep -oE 'eng-[0-9]+' | head -1)

    assert "$ticket" same_as "eng-1045"
}

@test 'Extracts first eng-XXXX when multiple present' {
    local ticket=$(echo "fix/eng-123-and-eng-456-related" | grep -oE 'eng-[0-9]+' | head -1)

    assert "$ticket" same_as "eng-123"
}

@test 'Handles large ticket numbers' {
    local ticket=$(echo "user/eng-99999-big-ticket" | grep -oE 'eng-[0-9]+' | head -1)

    assert "$ticket" same_as "eng-99999"
}

@test 'Extracts from deeply nested prefixes' {
    local ticket=$(echo "team/user/eng-6000-deep" | grep -oE 'eng-[0-9]+' | head -1)

    assert "$ticket" same_as "eng-6000"
}

# =============================================================================
# Regular Branch Name Extraction Tests
# =============================================================================

@test 'Extracts first 3 words from regular branch' {
    local name=$(echo "feature/add-new-dashboard-components-extra" | sed 's|^[^/]*/||' | tr '-' '\n' | head -3 | tr '\n' '-' | sed 's/-$//')

    assert "$name" same_as "add-new-dashboard"
}

@test 'Handles branch with fewer than 3 words' {
    local name=$(echo "fix/quick-patch" | sed 's|^[^/]*/||' | tr '-' '\n' | head -3 | tr '\n' '-' | sed 's/-$//')

    assert "$name" same_as "quick-patch"
}

@test 'Strips common prefixes' {
    local name=$(echo "hotfix/urgent-security-fix-now" | sed 's|^[^/]*/||' | tr '-' '\n' | head -3 | tr '\n' '-' | sed 's/-$//')

    assert "$name" same_as "urgent-security-fix"
}

# =============================================================================
# Worktree Path Construction Tests
# =============================================================================

@test 'Constructs correct path for Linear branch' {
    create_test_repo

    run gwt aasim/eng-1045-test-branch

    assert "$output" contains "test-repo-eng-1045"
    cleanup_test_repo
}

@test 'Constructs correct path for regular branch' {
    create_test_repo

    run gwt feature/add-new-thing-here

    assert "$output" contains "test-repo-add-new-thing"
    cleanup_test_repo
}

# =============================================================================
# Worktree Creation Tests
# =============================================================================

@test 'Creates new worktree successfully' {
    create_test_repo

    run gwt test/eng-3000-new-feature

    assert $state equals 0
    cleanup_test_repo
}

@test 'Shows success message' {
    create_test_repo

    run gwt test/eng-3001-success-msg

    assert "$output" contains "Worktree created successfully"
    cleanup_test_repo
}

@test 'Worktree directory exists after creation' {
    create_test_repo
    local expected_path="$PARENT_DIR/test-repo-eng-3002"

    gwt test/eng-3002-dir-exists >/dev/null 2>&1

    assert "$expected_path" is_dir
    cleanup_test_repo
}

@test 'Worktree is on correct branch' {
    create_test_repo

    gwt test/eng-4000-branch-check >/dev/null 2>&1
    cd "$PARENT_DIR/test-repo-eng-4000"
    local current_branch=$(git rev-parse --abbrev-ref HEAD)

    assert "$current_branch" same_as "test/eng-4000-branch-check"
    cleanup_test_repo
}

# =============================================================================
# Existing Worktree Handling Tests
# =============================================================================

@test 'Returns success for existing worktree' {
    create_test_repo
    local worktree_path="$PARENT_DIR/test-repo-eng-2000"
    git worktree add -q -b test/eng-2000-exists "$worktree_path" HEAD

    run gwt test/eng-2000-exists

    assert $state equals 0
    cleanup_test_repo
}

@test 'Detects existing worktree' {
    create_test_repo
    local worktree_path="$PARENT_DIR/test-repo-eng-2001"
    git worktree add -q -b test/eng-2001-exists "$worktree_path" HEAD

    run gwt test/eng-2001-exists

    assert "$output" contains "Worktree already exists"
    cleanup_test_repo
}

@test 'Shows cd message for existing worktree' {
    create_test_repo
    local worktree_path="$PARENT_DIR/test-repo-eng-2002"
    git worktree add -q -b test/eng-2002-exists "$worktree_path" HEAD

    run gwt test/eng-2002-exists

    assert "$output" contains "Changing to existing worktree"
    cleanup_test_repo
}

# =============================================================================
# Copy Config Dirs Flag Tests
# =============================================================================

@test '--copy-config-dirs flag creates worktree successfully' {
    create_test_repo
    mkdir -p serena
    echo "config" > serena/config.yml

    run gwt --copy-config-dirs serena test/eng-5000-copy-test

    assert $state equals 0
    cleanup_test_repo
}

@test '--copy-config-dirs flag copies config dir to worktree' {
    create_test_repo
    mkdir -p serena
    echo "config" > serena/config.yml

    gwt --copy-config-dirs serena test/eng-5000-copy-test2 >/dev/null 2>&1

    assert "$PARENT_DIR/test-repo-eng-5000/serena" is_dir
    cleanup_test_repo
}

@test '--copy-config-dirs flag handles multiple dirs' {
    create_test_repo
    mkdir -p serena .vscode
    echo "config" > serena/config.yml
    echo "settings" > .vscode/settings.json

    run gwt --copy-config-dirs serena --copy-config-dirs .vscode test/eng-5001-multi-copy

    assert $state equals 0
    cleanup_test_repo
}

@test '--copy-config-dirs flag copies first dir' {
    create_test_repo
    mkdir -p serena .vscode
    echo "config" > serena/config.yml
    echo "settings" > .vscode/settings.json

    gwt --copy-config-dirs serena --copy-config-dirs .vscode test/eng-5001-multi-copy2 >/dev/null 2>&1

    assert "$PARENT_DIR/test-repo-eng-5001/serena" is_dir
    cleanup_test_repo
}

@test '--copy-config-dirs flag copies second dir' {
    create_test_repo
    mkdir -p serena .vscode
    echo "config" > serena/config.yml
    echo "settings" > .vscode/settings.json

    gwt --copy-config-dirs serena --copy-config-dirs .vscode test/eng-5001-multi-copy3 >/dev/null 2>&1

    assert "$PARENT_DIR/test-repo-eng-5001/.vscode" is_dir
    cleanup_test_repo
}

# =============================================================================
# GWT_COPY_DIRS Env Var Tests
# =============================================================================

@test 'GWT_COPY_DIRS env var creates worktree successfully' {
    create_test_repo
    mkdir -p serena
    echo "config" > serena/config.yml
    export GWT_COPY_DIRS="serena"

    run gwt test/eng-5002-env-test

    assert $state equals 0
    unset GWT_COPY_DIRS
    cleanup_test_repo
}

@test 'GWT_COPY_DIRS env var copies config dir' {
    create_test_repo
    mkdir -p serena
    echo "config" > serena/config.yml
    export GWT_COPY_DIRS="serena"

    gwt test/eng-5002-env-test2 >/dev/null 2>&1

    assert "$PARENT_DIR/test-repo-eng-5002/serena" is_dir
    unset GWT_COPY_DIRS
    cleanup_test_repo
}

@test 'GWT_COPY_DIRS env var handles multiple dirs' {
    create_test_repo
    mkdir -p serena .vscode
    echo "config" > serena/config.yml
    echo "settings" > .vscode/settings.json
    export GWT_COPY_DIRS="serena,.vscode"

    run gwt test/eng-5003-env-multi

    assert $state equals 0
    unset GWT_COPY_DIRS
    cleanup_test_repo
}

@test 'GWT_COPY_DIRS env var copies first dir from list' {
    create_test_repo
    mkdir -p serena .vscode
    echo "config" > serena/config.yml
    echo "settings" > .vscode/settings.json
    export GWT_COPY_DIRS="serena,.vscode"

    gwt test/eng-5003-env-multi2 >/dev/null 2>&1

    assert "$PARENT_DIR/test-repo-eng-5003/serena" is_dir
    unset GWT_COPY_DIRS
    cleanup_test_repo
}

@test 'GWT_COPY_DIRS env var copies second dir from list' {
    create_test_repo
    mkdir -p serena .vscode
    echo "config" > serena/config.yml
    echo "settings" > .vscode/settings.json
    export GWT_COPY_DIRS="serena,.vscode"

    gwt test/eng-5003-env-multi3 >/dev/null 2>&1

    assert "$PARENT_DIR/test-repo-eng-5003/.vscode" is_dir
    unset GWT_COPY_DIRS
    cleanup_test_repo
}

# =============================================================================
# Copy Config Dirs Warning Tests
# =============================================================================

@test 'Non-existent dir still creates worktree successfully' {
    create_test_repo

    run gwt --copy-config-dirs nonexistent test/eng-5004-warn-test

    assert $state equals 0
    cleanup_test_repo
}

@test 'Non-existent dir shows warning message' {
    create_test_repo

    run gwt --copy-config-dirs nonexistent test/eng-5004-warn-test2

    assert "$output" contains "Warning"
    cleanup_test_repo
}

@test 'Non-existent dir warning mentions directory name' {
    create_test_repo

    run gwt --copy-config-dirs nonexistent test/eng-5004-warn-test3

    assert "$output" contains "nonexistent"
    cleanup_test_repo
}

# =============================================================================
# Config Command Tests
# =============================================================================

@test 'gwt --config works outside git repo' {
    local test_dir=$(mktemp -d)
    mkdir -p "$test_dir/not-a-repo"
    cd "$test_dir/not-a-repo"

    run gwt --config --help

    assert $state equals 0
    rm -rf "$test_dir"
}

@test 'gwt --config shows config help' {
    local test_dir=$(mktemp -d)
    mkdir -p "$test_dir/not-a-repo"
    cd "$test_dir/not-a-repo"

    run gwt --config --help

    assert "$output" contains "config"
    rm -rf "$test_dir"
}

@test '_gwt_config_read extracts dirs from zshrc' {
    local test_dir=$(mktemp -d)
    local test_zshrc="$test_dir/test_zshrc"
    echo 'export GWT_COPY_DIRS="serena,.vscode"' > "$test_zshrc"

    local result=$(_gwt_config_read "$test_zshrc")

    assert "$result" same_as "serena,.vscode"
    rm -rf "$test_dir"
}

@test '_gwt_config_read returns empty when no config' {
    local test_dir=$(mktemp -d)
    local test_zshrc="$test_dir/test_zshrc"
    echo '# just a comment' > "$test_zshrc"

    local result=$(_gwt_config_read "$test_zshrc")

    assert "$result" is_empty
    rm -rf "$test_dir"
}

@test '_gwt_config_write adds config to file' {
    local test_dir=$(mktemp -d)
    local test_zshrc="$test_dir/test_zshrc"
    echo '# my zshrc' > "$test_zshrc"

    _gwt_config_write "$test_zshrc" "serena"

    assert "$(cat "$test_zshrc")" contains 'export GWT_COPY_DIRS="serena"'
    rm -rf "$test_dir"
}

@test '_gwt_config_write replaces existing without duplicates' {
    local test_dir=$(mktemp -d)
    local test_zshrc="$test_dir/test_zshrc"
    echo 'export GWT_COPY_DIRS="old"' > "$test_zshrc"

    _gwt_config_write "$test_zshrc" "serena,.vscode"
    local count=$(grep -c 'GWT_COPY_DIRS' "$test_zshrc")

    assert "$count" equals 1
    rm -rf "$test_dir"
}

@test '_gwt_config_write updates with new value' {
    local test_dir=$(mktemp -d)
    local test_zshrc="$test_dir/test_zshrc"
    echo 'export GWT_COPY_DIRS="old"' > "$test_zshrc"

    _gwt_config_write "$test_zshrc" "serena,.vscode"

    assert "$(cat "$test_zshrc")" contains 'export GWT_COPY_DIRS="serena,.vscode"'
    rm -rf "$test_dir"
}

@test '_gwt_config_write removes line when value is empty' {
    local test_dir=$(mktemp -d)
    local test_zshrc="$test_dir/test_zshrc"
    echo 'export GWT_COPY_DIRS="serena"' > "$test_zshrc"

    _gwt_config_write "$test_zshrc" ""
    local content=$(cat "$test_zshrc")

    assert "$content" does_not_contain "GWT_COPY_DIRS"
    rm -rf "$test_dir"
}

# =============================================================================
# Version and Update Tests
# =============================================================================

@test 'gwt --version shows version' {
    run gwt --version

    assert $state equals 0
    assert "$output" contains "gwt version"
}

@test 'gwt --version works outside git repo' {
    local test_dir=$(mktemp -d)
    mkdir -p "$test_dir/not-a-repo"
    cd "$test_dir/not-a-repo"

    run gwt --version

    assert $state equals 0
    assert "$output" contains "gwt version"
    rm -rf "$test_dir"
}

@test 'gwt --update runs update check' {
    run gwt --update

    # Should either succeed (if installed via git) or fail gracefully
    # Output should show it attempted to update
    assert "$output" contains "gwt"
}

# =============================================================================
# Security Tests
# =============================================================================

@test '_gwt_validate_dir accepts simple name' {
    run _gwt_validate_dir "serena"

    assert $state equals 0
}

@test '_gwt_validate_dir accepts dotfile' {
    run _gwt_validate_dir ".vscode"

    assert $state equals 0
}

@test '_gwt_validate_dir accepts relative path' {
    run _gwt_validate_dir "path/to/dir"

    assert $state equals 0
}

@test '_gwt_validate_dir rejects path traversal' {
    run _gwt_validate_dir "../etc"

    assert $state equals 1
}

@test '_gwt_validate_dir rejects absolute path' {
    run _gwt_validate_dir "/etc/passwd"

    assert $state equals 1
}

@test '_gwt_validate_dir rejects semicolon' {
    run _gwt_validate_dir "foo;rm"

    assert $state equals 1
}

@test '_gwt_validate_dir rejects pipe' {
    run _gwt_validate_dir "foo|bar"

    assert $state equals 1
}

@test '_gwt_validate_dir rejects empty string' {
    run _gwt_validate_dir ""

    assert $state equals 1
}

@test 'Security: rejects path traversal in --copy-config-dirs' {
    create_test_repo

    run gwt --copy-config-dirs "../../../etc" test/eng-6000-traversal

    assert $state equals 1
    cleanup_test_repo
}

@test 'Security: shows error for path traversal' {
    create_test_repo

    run gwt --copy-config-dirs "../../../etc" test/eng-6000-traversal2

    assert "$output" contains "Invalid directory"
    cleanup_test_repo
}

@test 'Security: rejects absolute paths' {
    create_test_repo

    run gwt --copy-config-dirs "/etc/passwd" test/eng-6001-absolute

    assert $state equals 1
    cleanup_test_repo
}

@test 'Security: shows error for absolute path' {
    create_test_repo

    run gwt --copy-config-dirs "/etc/passwd" test/eng-6001-absolute2

    assert "$output" contains "Invalid directory"
    cleanup_test_repo
}

@test 'Security: rejects shell metacharacters' {
    create_test_repo

    run gwt --copy-config-dirs 'foo;rm -rf /' test/eng-6002-injection

    assert $state equals 1
    cleanup_test_repo
}

@test 'Security: shows error for metacharacters' {
    create_test_repo

    run gwt --copy-config-dirs 'foo;rm -rf /' test/eng-6002-injection2

    assert "$output" contains "Invalid directory"
    cleanup_test_repo
}

@test 'Security: config write sanitizes quotes' {
    local test_dir=$(mktemp -d)
    local test_zshrc="$test_dir/test_zshrc"
    echo '# test' > "$test_zshrc"

    _gwt_config_write "$test_zshrc" 'serena"; echo "pwned'
    local content=$(cat "$test_zshrc")

    # Verify quotes were sanitized (pwned should not appear or be escaped)
    assert "$content" does_not_contain "pwned"
    rm -rf "$test_dir"
}

@test 'Security: no git push/remote operations' {
    create_test_repo
    # Safety: Use TEST_DIR which is verified to be in temp
    local git_log="$TEST_DIR/gwt_git_log"

    # Create a mock git that logs all commands
    mkdir -p "$TEST_DIR/bin"
    echo '#!/bin/zsh
echo "$@" >> '"$git_log"'
/usr/bin/git "$@"' > "$TEST_DIR/bin/git"
    chmod +x "$TEST_DIR/bin/git"

    PATH="$TEST_DIR/bin:$PATH" gwt test/eng-6003-security >/dev/null 2>&1

    local has_forbidden=false
    if [[ -f "$git_log" ]]; then
        # Check for forbidden git operations (word boundaries with \b)
        if grep -qE '\b(push|clone)\b|remote add' "$git_log" 2>/dev/null; then
            has_forbidden=true
        fi
        # git_log is inside TEST_DIR, cleaned up by cleanup_test_repo
    fi

    assert "$has_forbidden" same_as "false"
    cleanup_test_repo
}

# =============================================================================
# --list Flag Tests
# =============================================================================

@test 'gwt --list requires git repo' {
    local test_dir=$(mktemp -d)
    mkdir -p "$test_dir/not-a-repo"
    cd "$test_dir/not-a-repo"

    run gwt --list

    assert $state equals 1
    assert "$output" contains "Not in a git repository"
    rm -rf "$test_dir"
}

@test 'gwt --list shows message when no worktrees' {
    create_test_repo

    run gwt --list

    assert $state equals 0
    assert "$output" contains "No worktrees"
    cleanup_test_repo
}

@test 'gwt --list shows worktrees when they exist' {
    create_test_repo
    local worktree_path="$PARENT_DIR/test-repo-eng-7000"
    git worktree add -q -b test/eng-7000-list "$worktree_path" HEAD

    run gwt --list

    assert $state equals 0
    assert "$output" contains "test-repo-eng-7000"
    cleanup_test_repo
}

@test 'gwt --list shows branch name' {
    create_test_repo
    local worktree_path="$PARENT_DIR/test-repo-eng-7001"
    git worktree add -q -b test/eng-7001-list-branch "$worktree_path" HEAD

    run gwt --list

    assert "$output" contains "test/eng-7001-list-branch"
    cleanup_test_repo
}

# =============================================================================
# --list-copy-dirs Flag Tests
# =============================================================================

@test 'gwt --list-copy-dirs shows message when no config' {
    # Clear any existing config and use empty test zshrc
    unset GWT_COPY_DIRS
    local test_dir=$(mktemp -d)
    local test_zshrc="$test_dir/test_zshrc"
    echo '# empty' > "$test_zshrc"

    # Override HOME to use test zshrc
    HOME="$test_dir" run gwt --list-copy-dirs

    assert $state equals 0
    assert "$output" contains "No directories configured"
    rm -rf "$test_dir"
}

@test 'gwt --list-copy-dirs shows configured dirs' {
    local test_dir=$(mktemp -d)
    local test_zshrc="$test_dir/.zshrc"
    echo 'export GWT_COPY_DIRS="serena,.vscode"' > "$test_zshrc"

    HOME="$test_dir" run gwt --list-copy-dirs

    assert $state equals 0
    assert "$output" contains "serena"
    assert "$output" contains ".vscode"
    rm -rf "$test_dir"
}

@test 'gwt --list-copy-dirs works outside git repo' {
    local test_dir=$(mktemp -d)
    mkdir -p "$test_dir/not-a-repo"
    cd "$test_dir/not-a-repo"

    run gwt --list-copy-dirs

    assert $state equals 0
    rm -rf "$test_dir"
}

# =============================================================================
# --prune Flag Tests
# =============================================================================

@test 'gwt --prune requires git repo' {
    local test_dir=$(mktemp -d)
    mkdir -p "$test_dir/not-a-repo"
    cd "$test_dir/not-a-repo"

    run gwt --prune

    assert $state equals 1
    assert "$output" contains "Not in a git repository"
    rm -rf "$test_dir"
}

@test 'gwt --prune shows message when no worktrees' {
    create_test_repo

    run gwt --prune

    assert $state equals 0
    assert "$output" contains "No worktrees to prune"
    cleanup_test_repo
}

@test 'gwt --prune shows worktrees for selection' {
    create_test_repo
    local worktree_path="$PARENT_DIR/test-repo-eng-8000"
    git worktree add -q -b test/eng-8000-prune "$worktree_path" HEAD

    # Send 'q' to quit immediately using here-string
    run gwt --prune <<< "q"

    assert $state equals 0
    assert "$output" contains "test-repo-eng-8000"
    cleanup_test_repo
}

# =============================================================================
# Cycle 1: Security Enhancement - Regex Escaping Tests
# =============================================================================

@test 'Security: config remove handles dot in directory name correctly' {
    # This tests the regex escaping fix for line 266
    # Without escaping, "foo.bar" could match "fooXbar" due to regex wildcard
    local test_dir=$(mktemp -d)
    local test_zshrc="$test_dir/.zshrc"
    echo 'export GWT_COPY_DIRS="foo.bar,fooXbar,other"' > "$test_zshrc"

    # Simulate the _gwt_config menu: choice 2 (remove), enter "foo.bar", choice 4 (done)
    HOME="$test_dir" run _gwt_config <<< $'2\nfoo.bar\n4'

    # Read the resulting config
    local result=$(_gwt_config_read "$test_zshrc")

    # fooXbar should still be present (not incorrectly matched by foo.bar pattern)
    assert "$result" contains "fooXbar"
    assert "$result" contains "other"
    # foo.bar should be removed
    assert "$result" does_not_contain "foo.bar"
    rm -rf "$test_dir"
}

# =============================================================================
# Cycle 2: Additional Security Validation Tests
# =============================================================================

@test '_gwt_validate_dir rejects backticks' {
    run _gwt_validate_dir '`rm -rf /`'

    assert $state equals 1
}

@test '_gwt_validate_dir rejects dollar sign' {
    run _gwt_validate_dir '$(rm -rf /)'

    assert $state equals 1
}

@test '_gwt_validate_dir rejects newlines' {
    run _gwt_validate_dir $'foo\nbar'

    assert $state equals 1
}

@test '_gwt_validate_dir rejects spaces' {
    run _gwt_validate_dir 'foo bar'

    assert $state equals 1
}

@test '_gwt_validate_dir rejects backslash' {
    run _gwt_validate_dir 'foo\\bar'

    assert $state equals 1
}

@test '_gwt_validate_dir rejects ampersand' {
    run _gwt_validate_dir 'foo&bar'

    assert $state equals 1
}

@test 'Security: GWT_COPY_DIRS with malicious content is filtered' {
    create_test_repo
    mkdir -p serena
    echo "config" > serena/config.yml
    # Attempt to inject malicious dirs via env var
    export GWT_COPY_DIRS="../../../etc,serena,/etc/passwd"

    run gwt test/eng-9001-env-security

    # Should succeed (malicious dirs filtered out, serena is valid)
    assert $state equals 0
    unset GWT_COPY_DIRS
    cleanup_test_repo
}

@test 'Security: config write sanitizes backticks' {
    local test_dir=$(mktemp -d)
    local test_zshrc="$test_dir/test_zshrc"
    echo '# test' > "$test_zshrc"

    _gwt_config_write "$test_zshrc" 'serena`whoami`'
    local content=$(cat "$test_zshrc")

    # Verify backticks were sanitized
    assert "$content" does_not_contain "\`"
    rm -rf "$test_dir"
}

@test 'Security: config write sanitizes dollar signs' {
    local test_dir=$(mktemp -d)
    local test_zshrc="$test_dir/test_zshrc"
    echo '# test' > "$test_zshrc"

    _gwt_config_write "$test_zshrc" 'serena$(whoami)'
    local content=$(cat "$test_zshrc")

    # Verify dollar signs were sanitized
    assert "$content" does_not_contain "\$"
    rm -rf "$test_dir"
}

# =============================================================================
# Cycle 3: _gwt_update() Tests
# =============================================================================

@test '_gwt_update shows error when install dir not found' {
    # Temporarily unset install dir and set to nonexistent
    # Also override HOME to prevent fallback paths from matching
    local old_install="$GWT_INSTALL_DIR"
    local test_dir=$(mktemp -d)
    GWT_INSTALL_DIR="/nonexistent/path/gwt"

    HOME="$test_dir" run _gwt_update

    assert $state equals 1
    assert "$output" contains "Could not find"
    GWT_INSTALL_DIR="$old_install"
    rm -rf "$test_dir"
}

@test '_gwt_update shows error when not a git repo' {
    local test_dir=$(mktemp -d)
    local old_install="$GWT_INSTALL_DIR"
    GWT_INSTALL_DIR="$test_dir"

    run _gwt_update

    assert $state equals 1
    assert "$output" contains "not a git repository"
    GWT_INSTALL_DIR="$old_install"
    rm -rf "$test_dir"
}

@test '_gwt_update shows already up to date when at HEAD' {
    # Use the actual gwt installation which is a git repo
    run _gwt_update

    # Should either show "up to date" or "Updating"
    assert $state equals 0
}

# =============================================================================
# Cycle 4: _gwt_config() Interactive Tests
# =============================================================================

@test '_gwt_config add directory to empty config' {
    local test_dir=$(mktemp -d)
    local test_zshrc="$test_dir/.zshrc"
    echo '# empty' > "$test_zshrc"

    # Menu: 1 (add), enter "serena", 4 (done)
    HOME="$test_dir" run _gwt_config <<< $'1\nserena\n4'

    local result=$(_gwt_config_read "$test_zshrc")
    assert "$result" same_as "serena"
    rm -rf "$test_dir"
}

@test '_gwt_config add directory to existing config' {
    local test_dir=$(mktemp -d)
    local test_zshrc="$test_dir/.zshrc"
    echo 'export GWT_COPY_DIRS="existing"' > "$test_zshrc"

    # Menu: 1 (add), enter "newdir", 4 (done)
    HOME="$test_dir" run _gwt_config <<< $'1\nnewdir\n4'

    local result=$(_gwt_config_read "$test_zshrc")
    assert "$result" contains "existing"
    assert "$result" contains "newdir"
    rm -rf "$test_dir"
}

@test '_gwt_config detects duplicate directory' {
    local test_dir=$(mktemp -d)
    local test_zshrc="$test_dir/.zshrc"
    echo 'export GWT_COPY_DIRS="serena"' > "$test_zshrc"

    # Menu: 1 (add), enter "serena" (duplicate), 4 (done)
    HOME="$test_dir" run _gwt_config <<< $'1\nserena\n4'

    assert "$output" contains "already configured"
    rm -rf "$test_dir"
}

@test '_gwt_config remove directory from config' {
    local test_dir=$(mktemp -d)
    local test_zshrc="$test_dir/.zshrc"
    echo 'export GWT_COPY_DIRS="serena,vscode"' > "$test_zshrc"

    # Menu: 2 (remove), enter "serena", 4 (done)
    HOME="$test_dir" run _gwt_config <<< $'2\nserena\n4'

    local result=$(_gwt_config_read "$test_zshrc")
    assert "$result" same_as "vscode"
    rm -rf "$test_dir"
}

@test '_gwt_config remove from empty shows message' {
    local test_dir=$(mktemp -d)
    local test_zshrc="$test_dir/.zshrc"
    echo '# empty' > "$test_zshrc"

    # Menu: 2 (remove), 4 (done)
    HOME="$test_dir" run _gwt_config <<< $'2\n4'

    assert "$output" contains "No directories to remove"
    rm -rf "$test_dir"
}

@test '_gwt_config list shows directories' {
    local test_dir=$(mktemp -d)
    local test_zshrc="$test_dir/.zshrc"
    echo 'export GWT_COPY_DIRS="serena,vscode"' > "$test_zshrc"

    # Menu: 3 (list), 4 (done)
    HOME="$test_dir" run _gwt_config <<< $'3\n4'

    assert "$output" contains "serena"
    assert "$output" contains "vscode"
    rm -rf "$test_dir"
}

@test '_gwt_config list empty shows no dirs message' {
    local test_dir=$(mktemp -d)
    local test_zshrc="$test_dir/.zshrc"
    echo '# empty' > "$test_zshrc"

    # Menu: 3 (list), 4 (done)
    HOME="$test_dir" run _gwt_config <<< $'3\n4'

    assert "$output" contains "No directories configured"
    rm -rf "$test_dir"
}

@test '_gwt_config invalid choice shows error' {
    local test_dir=$(mktemp -d)
    local test_zshrc="$test_dir/.zshrc"
    echo '# empty' > "$test_zshrc"

    # Menu: 9 (invalid), 4 (done)
    HOME="$test_dir" run _gwt_config <<< $'9\n4'

    assert "$output" contains "Invalid choice"
    rm -rf "$test_dir"
}

# =============================================================================
# Cycle 5: _gwt_prune() Tests
# =============================================================================

@test 'gwt --prune fallback selection with specific number' {
    create_test_repo
    local worktree_path="$PARENT_DIR/test-repo-eng-8100"
    git worktree add -q -b test/eng-8100-prune-num "$worktree_path" HEAD

    # Select worktree 1, then cancel at first confirmation
    run gwt --prune <<< $'1\nn'

    assert $state equals 0
    assert "$output" contains "Cancelled"
    cleanup_test_repo
}

@test 'gwt --prune fallback selection with all' {
    create_test_repo
    local worktree_path="$PARENT_DIR/test-repo-eng-8101"
    git worktree add -q -b test/eng-8101-prune-all "$worktree_path" HEAD

    # Select 'all', then cancel at first confirmation
    run gwt --prune <<< $'all\nn'

    assert $state equals 0
    assert "$output" contains "Cancelled"
    cleanup_test_repo
}

@test 'gwt --prune shows uncommitted changes warning' {
    create_test_repo
    local worktree_path="$PARENT_DIR/test-repo-eng-8102"
    git worktree add -q -b test/eng-8102-uncommitted "$worktree_path" HEAD

    # Create uncommitted change in worktree
    echo "uncommitted" > "$worktree_path/uncommitted.txt"

    # Select worktree 1, then cancel
    run gwt --prune <<< $'1\nn'

    assert "$output" contains "WARNING"
    assert "$output" contains "Uncommitted"
    cleanup_test_repo
}

@test 'gwt --prune cancels on first confirmation' {
    create_test_repo
    local worktree_path="$PARENT_DIR/test-repo-eng-8103"
    git worktree add -q -b test/eng-8103-cancel1 "$worktree_path" HEAD

    # Select worktree 1, then 'n' at first confirmation
    run gwt --prune <<< $'1\nn'

    assert $state equals 0
    assert "$output" contains "Cancelled"
    # Worktree should still exist
    assert "$worktree_path" is_dir
    cleanup_test_repo
}

@test 'gwt --prune cancels on DELETE confirmation' {
    create_test_repo
    local worktree_path="$PARENT_DIR/test-repo-eng-8104"
    git worktree add -q -b test/eng-8104-cancel2 "$worktree_path" HEAD

    # Select worktree 1, 'y' at first confirmation, then wrong text
    run gwt --prune <<< $'1\ny\nwrong'

    assert $state equals 0
    assert "$output" contains "Cancelled"
    # Worktree should still exist
    assert "$worktree_path" is_dir
    cleanup_test_repo
}

@test 'gwt --prune deletes worktree on full confirmation' {
    create_test_repo
    local worktree_path="$PARENT_DIR/test-repo-eng-8105"
    git worktree add -q -b test/eng-8105-delete "$worktree_path" HEAD

    # Select worktree 1, 'y', then 'DELETE'
    run gwt --prune <<< $'1\ny\nDELETE'

    assert $state equals 0
    assert "$output" contains "Done"
    # Worktree should be removed (check that it does NOT exist)
    [[ ! -d "$worktree_path" ]]
    assert $? equals 0
    cleanup_test_repo
}

# =============================================================================
# Cycle 6: gwt() Edge Case Tests
# =============================================================================

@test 'gwt rejects unknown option' {
    create_test_repo

    run gwt --unknown-flag

    assert $state equals 1
    assert "$output" contains "Unknown option"
    cleanup_test_repo
}

@test 'gwt --copy-config-dirs without argument shows error' {
    create_test_repo

    run gwt --copy-config-dirs

    assert $state equals 1
    assert "$output" contains "requires"
    cleanup_test_repo
}

@test 'gwt uses local branch when exists' {
    create_test_repo
    # Create a local branch
    git branch test/eng-9000-local

    run gwt test/eng-9000-local

    assert $state equals 0
    assert "$output" contains "Worktree created"
    cleanup_test_repo
}

@test 'gwt creates new branch when not found' {
    create_test_repo

    run gwt test/eng-9010-newbranch

    assert $state equals 0
    assert "$output" contains "Worktree created"
    # Verify the branch was created
    local wt_path="$PARENT_DIR/test-repo-eng-9010"
    local branch=$(cd "$wt_path" && git branch --show-current)
    assert "$branch" same_as "test/eng-9010-newbranch"
    cleanup_test_repo
}

@test 'gwt handles branch with slash prefix correctly' {
    create_test_repo

    run gwt feature/add-user-auth-flow

    assert $state equals 0
    # Should extract 3 words after prefix
    assert "$output" contains "test-repo-add-user-auth"
    cleanup_test_repo
}

# =============================================================================
# Cycle 7: _gwt_print() Helper Tests
# =============================================================================

@test '_gwt_print outputs message' {
    run _gwt_print "Test message"

    assert $state equals 0
    assert "$output" contains "Test message"
}

@test '_gwt_print outputs message with color' {
    run _gwt_print "Colored message" "green"

    assert $state equals 0
    assert "$output" contains "Colored message"
}

@test '_gwt_print outputs message with prefix symbol' {
    run _gwt_print "Symbol message" "green" "✓"

    assert $state equals 0
    assert "$output" contains "Symbol message"
    assert "$output" contains "✓"
}

# =============================================================================
# --help Flag Tests
# =============================================================================

@test 'gwt --help shows help message' {
    run gwt --help

    assert $state equals 0
    assert "$output" contains "Usage:"
    assert "$output" contains "Options:"
    assert "$output" contains "GWT_COPY_DIRS"
}

@test 'gwt -h shows help message' {
    run gwt -h

    assert $state equals 0
    assert "$output" contains "Usage:"
}

@test 'gwt --help works outside git repo' {
    local test_dir=$(mktemp -d)
    mkdir -p "$test_dir/not-a-repo"
    cd "$test_dir/not-a-repo"

    run gwt --help

    assert $state equals 0
    assert "$output" contains "gwt - Git Worktree helper"
    rm -rf "$test_dir"
}

# =============================================================================
# Phase 1: Branch Validation Tests (_gwt_validate_branch)
# =============================================================================

@test '_gwt_validate_branch accepts simple branch name' {
    run _gwt_validate_branch "feature-branch"

    assert $state equals 0
}

@test '_gwt_validate_branch accepts branch with slash' {
    run _gwt_validate_branch "feature/add-new-thing"

    assert $state equals 0
}

@test '_gwt_validate_branch accepts branch with multiple slashes' {
    run _gwt_validate_branch "user/team/eng-1234-feature"

    assert $state equals 0
}

@test '_gwt_validate_branch accepts main' {
    run _gwt_validate_branch "main"

    assert $state equals 0
}

@test '_gwt_validate_branch accepts master' {
    run _gwt_validate_branch "master"

    assert $state equals 0
}

@test '_gwt_validate_branch rejects empty string' {
    run _gwt_validate_branch ""

    assert $state equals 1
}

@test '_gwt_validate_branch rejects path traversal' {
    run _gwt_validate_branch "../etc/passwd"

    assert $state equals 1
}

@test '_gwt_validate_branch rejects semicolon' {
    run _gwt_validate_branch "branch;rm -rf /"

    assert $state equals 1
}

@test '_gwt_validate_branch rejects pipe' {
    run _gwt_validate_branch "branch|cat /etc/passwd"

    assert $state equals 1
}

@test '_gwt_validate_branch rejects backticks' {
    run _gwt_validate_branch 'branch`whoami`'

    assert $state equals 1
}

@test '_gwt_validate_branch rejects dollar sign' {
    run _gwt_validate_branch 'branch$(whoami)'

    assert $state equals 1
}

@test '_gwt_validate_branch rejects spaces' {
    run _gwt_validate_branch 'branch with spaces'

    assert $state equals 1
}

@test '_gwt_validate_branch rejects newlines' {
    run _gwt_validate_branch $'branch\ninjection'

    assert $state equals 1
}

# =============================================================================
# Phase 1: Metadata Storage Tests (_gwt_metadata_set/get/clear)
# =============================================================================

@test '_gwt_metadata_set stores base branch in worktree config' {
    create_test_repo
    local worktree_path="$PARENT_DIR/test-repo-eng-meta-1"
    git worktree add -q -b test/eng-meta-1 "$worktree_path" HEAD
    cd "$worktree_path"

    _gwt_metadata_set "feature/parent-branch" "$REPO_DIR"

    local stored=$(git config --worktree gwt.baseBranch 2>/dev/null)
    assert "$stored" same_as "feature/parent-branch"
    cleanup_test_repo
}

@test '_gwt_metadata_set stores base worktree path' {
    create_test_repo
    local worktree_path="$PARENT_DIR/test-repo-eng-meta-2"
    git worktree add -q -b test/eng-meta-2 "$worktree_path" HEAD
    cd "$worktree_path"

    _gwt_metadata_set "feature/parent" "$REPO_DIR"

    local stored=$(git config --worktree gwt.baseWorktreePath 2>/dev/null)
    assert "$stored" same_as "$REPO_DIR"
    cleanup_test_repo
}

@test '_gwt_metadata_get retrieves base branch' {
    create_test_repo
    local worktree_path="$PARENT_DIR/test-repo-eng-meta-3"
    git worktree add -q -b test/eng-meta-3 "$worktree_path" HEAD
    cd "$worktree_path"
    git config extensions.worktreeConfig true
    git config --worktree gwt.baseBranch "feature/stored-branch"

    local result=$(_gwt_metadata_get "baseBranch")

    assert "$result" same_as "feature/stored-branch"
    cleanup_test_repo
}

@test '_gwt_metadata_get retrieves base worktree path' {
    create_test_repo
    local worktree_path="$PARENT_DIR/test-repo-eng-meta-4"
    git worktree add -q -b test/eng-meta-4 "$worktree_path" HEAD
    cd "$worktree_path"
    git config extensions.worktreeConfig true
    git config --worktree gwt.baseWorktreePath "/some/path/to/worktree"

    local result=$(_gwt_metadata_get "baseWorktreePath")

    assert "$result" same_as "/some/path/to/worktree"
    cleanup_test_repo
}

@test '_gwt_metadata_get returns empty when no metadata' {
    create_test_repo
    local worktree_path="$PARENT_DIR/test-repo-eng-meta-5"
    git worktree add -q -b test/eng-meta-5 "$worktree_path" HEAD
    cd "$worktree_path"

    local result=$(_gwt_metadata_get "baseBranch")

    assert "$result" is_empty
    cleanup_test_repo
}

@test '_gwt_metadata_clear removes base branch metadata' {
    create_test_repo
    local worktree_path="$PARENT_DIR/test-repo-eng-meta-6"
    git worktree add -q -b test/eng-meta-6 "$worktree_path" HEAD
    cd "$worktree_path"
    git config extensions.worktreeConfig true
    git config --worktree gwt.baseBranch "feature/to-remove"
    git config --worktree gwt.baseWorktreePath "/some/path"

    _gwt_metadata_clear

    local branch=$(git config --worktree gwt.baseBranch 2>/dev/null)
    local path=$(git config --worktree gwt.baseWorktreePath 2>/dev/null)
    assert "$branch" is_empty
    assert "$path" is_empty
    cleanup_test_repo
}

# =============================================================================
# Phase 1: Registry Tests (_gwt_registry_add/remove/get_dependents)
# =============================================================================

@test '_gwt_registry_add stores worktree in central registry' {
    create_test_repo
    local worktree_path="$PARENT_DIR/test-repo-eng-reg-1"
    git worktree add -q -b test/eng-reg-1 "$worktree_path" HEAD

    _gwt_registry_add "test-repo-eng-reg-1" "feature/parent" "$REPO_DIR"

    local stored=$(git config "gwt.registry.test-repo-eng-reg-1.baseBranch")
    assert "$stored" same_as "feature/parent"
    cleanup_test_repo
}

@test '_gwt_registry_add stores base path in central registry' {
    create_test_repo
    local worktree_path="$PARENT_DIR/test-repo-eng-reg-2"
    git worktree add -q -b test/eng-reg-2 "$worktree_path" HEAD

    _gwt_registry_add "test-repo-eng-reg-2" "feature/parent" "$REPO_DIR"

    local stored=$(git config "gwt.registry.test-repo-eng-reg-2.basePath")
    assert "$stored" same_as "$REPO_DIR"
    cleanup_test_repo
}

@test '_gwt_registry_remove clears worktree from registry' {
    create_test_repo
    git config "gwt.registry.test-wt.baseBranch" "feature/test"
    git config "gwt.registry.test-wt.basePath" "/some/path"

    _gwt_registry_remove "test-wt"

    local branch=$(git config "gwt.registry.test-wt.baseBranch" 2>/dev/null)
    assert "$branch" is_empty
    cleanup_test_repo
}

@test '_gwt_registry_get_dependents finds worktrees based on branch' {
    create_test_repo
    # Set up registry entries - two worktrees depending on feature/parent
    git config "gwt.registry.child-wt-1.baseBranch" "feature/parent"
    git config "gwt.registry.child-wt-1.basePath" "$REPO_DIR"
    git config "gwt.registry.child-wt-2.baseBranch" "feature/parent"
    git config "gwt.registry.child-wt-2.basePath" "$REPO_DIR"
    git config "gwt.registry.other-wt.baseBranch" "feature/other"
    git config "gwt.registry.other-wt.basePath" "$REPO_DIR"

    local result=$(_gwt_registry_get_dependents "feature/parent")

    assert "$result" contains "child-wt-1"
    assert "$result" contains "child-wt-2"
    assert "$result" does_not_contain "other-wt"
    cleanup_test_repo
}

@test '_gwt_registry_get_dependents returns empty when no dependents' {
    create_test_repo
    git config "gwt.registry.some-wt.baseBranch" "feature/other"
    git config "gwt.registry.some-wt.basePath" "$REPO_DIR"

    local result=$(_gwt_registry_get_dependents "feature/no-dependents")

    assert "$result" is_empty
    cleanup_test_repo
}

# =============================================================================
# Phase 1: GWT_MAIN_BRANCH Configuration Tests
# =============================================================================

@test '_gwt_config_read_main extracts main branch from zshrc' {
    local test_dir=$(mktemp -d)
    local test_zshrc="$test_dir/test_zshrc"
    echo 'export GWT_MAIN_BRANCH="develop"' > "$test_zshrc"

    local result=$(_gwt_config_read_main "$test_zshrc")

    assert "$result" same_as "develop"
    rm -rf "$test_dir"
}

@test '_gwt_config_read_main returns empty when not set' {
    local test_dir=$(mktemp -d)
    local test_zshrc="$test_dir/test_zshrc"
    echo '# no main branch config' > "$test_zshrc"

    local result=$(_gwt_config_read_main "$test_zshrc")

    assert "$result" is_empty
    rm -rf "$test_dir"
}

@test '_gwt_get_main_branch returns GWT_MAIN_BRANCH when set' {
    export GWT_MAIN_BRANCH="develop"

    local result=$(_gwt_get_main_branch)

    assert "$result" same_as "develop"
    unset GWT_MAIN_BRANCH
}

@test '_gwt_get_main_branch defaults to main when not set' {
    unset GWT_MAIN_BRANCH

    local result=$(_gwt_get_main_branch)

    assert "$result" same_as "main"
}

# =============================================================================
# Phase 2: Default Base Branch Change Tests (HEAD -> main)
# =============================================================================

@test 'gwt creates new branch from main branch by default' {
    create_test_repo
    # Create a feature branch and switch to it
    git checkout -q -b feature/current-work
    echo "feature work" > feature.txt
    git add feature.txt
    git commit -q -m "Feature commit"

    # Create a new worktree - should be based on main, not current branch
    gwt test/eng-base-1 >/dev/null 2>&1

    # Check that the new branch is based on main (doesn't have feature.txt)
    cd "$PARENT_DIR/test-repo-eng-base-1"
    [[ ! -f "feature.txt" ]]
    assert $? equals 0
    cleanup_test_repo
}

@test 'gwt respects GWT_MAIN_BRANCH env var for base' {
    create_test_repo
    # Create develop branch with unique content
    git checkout -q -b develop
    echo "develop content" > develop.txt
    git add develop.txt
    git commit -q -m "Develop commit"
    git checkout -q main

    # Set GWT_MAIN_BRANCH to develop
    export GWT_MAIN_BRANCH="develop"

    gwt test/eng-base-2 >/dev/null 2>&1

    # Check that the new branch has develop.txt (based on develop)
    assert "$PARENT_DIR/test-repo-eng-base-2/develop.txt" is_file
    unset GWT_MAIN_BRANCH
    cleanup_test_repo
}

@test 'gwt falls back to HEAD when main branch does not exist' {
    create_test_repo
    # Rename main to something else
    git branch -m main old-main
    git checkout -q -b current-branch
    echo "current content" > current.txt
    git add current.txt
    git commit -q -m "Current commit"

    gwt test/eng-base-3 >/dev/null 2>&1

    # Should have created from HEAD (current-branch) since main doesn't exist
    assert "$PARENT_DIR/test-repo-eng-base-3/current.txt" is_file
    cleanup_test_repo
}

# =============================================================================
# Phase 3: --stack Flag Tests
# =============================================================================

@test 'gwt --stack creates worktree from current branch' {
    create_test_repo
    # Create a parent feature branch with unique content
    git checkout -q -b feature/parent-branch
    echo "parent content" > parent.txt
    git add parent.txt
    git commit -q -m "Parent commit"

    # Stack a new worktree from current branch
    gwt --stack test/eng-stack-1 >/dev/null 2>&1

    # Check that the new branch has parent.txt (based on feature/parent-branch)
    assert "$PARENT_DIR/test-repo-eng-stack-1/parent.txt" is_file
    cleanup_test_repo
}

@test 'gwt -s is alias for --stack' {
    create_test_repo
    git checkout -q -b feature/parent-short
    echo "short parent" > short.txt
    git add short.txt
    git commit -q -m "Short commit"

    gwt -s test/eng-stack-2 >/dev/null 2>&1

    assert "$PARENT_DIR/test-repo-eng-stack-2/short.txt" is_file
    cleanup_test_repo
}

@test 'gwt --stack stores base branch metadata' {
    create_test_repo
    git checkout -q -b feature/meta-parent
    echo "meta content" > meta.txt
    git add meta.txt
    git commit -q -m "Meta commit"

    gwt --stack test/eng-stack-3 >/dev/null 2>&1

    cd "$PARENT_DIR/test-repo-eng-stack-3"
    local base_branch=$(_gwt_metadata_get "baseBranch")
    assert "$base_branch" same_as "feature/meta-parent"
    cleanup_test_repo
}

@test 'gwt --stack stores base worktree path metadata' {
    create_test_repo
    git checkout -q -b feature/path-parent
    local parent_path=$(pwd)

    gwt --stack test/eng-stack-4 >/dev/null 2>&1

    cd "$PARENT_DIR/test-repo-eng-stack-4"
    local base_path=$(_gwt_metadata_get "baseWorktreePath")
    assert "$base_path" same_as "$parent_path"
    cleanup_test_repo
}

@test 'gwt --stack adds entry to central registry' {
    create_test_repo
    git checkout -q -b feature/reg-parent

    gwt --stack test/eng-stack-5 >/dev/null 2>&1

    cd "$REPO_DIR"
    local reg_branch=$(git config "gwt.registry.test-repo-eng-stack-5.baseBranch")
    assert "$reg_branch" same_as "feature/reg-parent"
    cleanup_test_repo
}

@test 'gwt --stack shows error in detached HEAD' {
    create_test_repo
    git checkout -q --detach HEAD

    run gwt --stack test/eng-stack-detached

    assert $state equals 1
    assert "$output" contains "detached HEAD"
    cleanup_test_repo
}

@test 'gwt --stack and --from together shows error' {
    create_test_repo

    run gwt --stack --from main test/eng-conflict

    assert $state equals 1
    assert "$output" contains "cannot"
    cleanup_test_repo
}

# =============================================================================
# Phase 4: --from Flag Tests
# =============================================================================

@test 'gwt --from creates worktree from specified branch' {
    create_test_repo
    # Create a specific branch to base from
    git checkout -q -b feature/specific-base
    echo "specific content" > specific.txt
    git add specific.txt
    git commit -q -m "Specific commit"
    git checkout -q main

    gwt --from feature/specific-base test/eng-from-1 >/dev/null 2>&1

    assert "$PARENT_DIR/test-repo-eng-from-1/specific.txt" is_file
    cleanup_test_repo
}

@test 'gwt -f is alias for --from' {
    create_test_repo
    git checkout -q -b feature/short-base
    echo "short base" > short-base.txt
    git add short-base.txt
    git commit -q -m "Short base commit"
    git checkout -q main

    gwt -f feature/short-base test/eng-from-2 >/dev/null 2>&1

    assert "$PARENT_DIR/test-repo-eng-from-2/short-base.txt" is_file
    cleanup_test_repo
}

@test 'gwt --from stores base branch metadata' {
    create_test_repo
    git checkout -q -b feature/from-meta
    git checkout -q main

    gwt --from feature/from-meta test/eng-from-3 >/dev/null 2>&1

    cd "$PARENT_DIR/test-repo-eng-from-3"
    local base_branch=$(_gwt_metadata_get "baseBranch")
    assert "$base_branch" same_as "feature/from-meta"
    cleanup_test_repo
}

@test 'gwt --from shows error when base branch does not exist' {
    create_test_repo

    run gwt --from nonexistent/branch test/eng-from-notfound

    assert $state equals 1
    assert "$output" contains "not found"
    cleanup_test_repo
}

@test 'gwt --from requires branch argument' {
    create_test_repo

    run gwt --from

    assert $state equals 1
    assert "$output" contains "requires"
    cleanup_test_repo
}

@test 'gwt --from validates branch name' {
    create_test_repo

    run gwt --from "invalid;branch" test/eng-from-invalid

    assert $state equals 1
    assert "$output" contains "Invalid"
    cleanup_test_repo
}

# =============================================================================
# Phase 5: Navigation (--base and ..) Tests
# =============================================================================

@test 'gwt --base navigates to base worktree' {
    create_test_repo
    local main_path=$(pwd)
    git checkout -q -b feature/nav-parent
    local parent_path=$(pwd)

    # Create stacked worktree
    gwt --stack test/eng-nav-1 >/dev/null 2>&1
    cd "$PARENT_DIR/test-repo-eng-nav-1"

    # Navigate back to base
    gwt --base

    assert $(pwd) same_as "$parent_path"
    cleanup_test_repo
}

@test 'gwt -b is alias for --base' {
    create_test_repo
    git checkout -q -b feature/nav-parent-short
    local parent_path=$(pwd)

    gwt --stack test/eng-nav-2 >/dev/null 2>&1
    cd "$PARENT_DIR/test-repo-eng-nav-2"

    gwt -b

    assert $(pwd) same_as "$parent_path"
    cleanup_test_repo
}

@test 'gwt .. navigates to base worktree' {
    create_test_repo
    git checkout -q -b feature/nav-parent-dots
    local parent_path=$(pwd)

    gwt --stack test/eng-nav-3 >/dev/null 2>&1
    cd "$PARENT_DIR/test-repo-eng-nav-3"

    gwt ..

    assert $(pwd) same_as "$parent_path"
    cleanup_test_repo
}

@test 'gwt --base shows error when no base tracked' {
    create_test_repo
    # This worktree was created without --stack, so no base metadata

    run gwt --base

    assert $state equals 1
    assert "$output" contains "No base"
    cleanup_test_repo
}

@test 'gwt .. shows error when no base tracked' {
    create_test_repo

    run gwt ..

    assert $state equals 1
    assert "$output" contains "No base"
    cleanup_test_repo
}

@test 'gwt --base shows error when base worktree deleted' {
    create_test_repo
    git checkout -q -b feature/deleted-parent
    local parent_path=$(pwd)

    gwt --stack test/eng-nav-deleted >/dev/null 2>&1
    cd "$PARENT_DIR/test-repo-eng-nav-deleted"

    # Delete the parent worktree directory (simulating deletion)
    # Note: We need to store a non-existent path as base
    _gwt_metadata_set "feature/deleted-parent" "/nonexistent/path"

    run gwt --base

    assert $state equals 1
    assert "$output" contains "no longer exists"
    cleanup_test_repo
}

@test 'gwt --base works after navigating away from stacked worktree' {
    create_test_repo
    git checkout -q -b feature/nav-away-parent
    local parent_path=$(pwd)

    gwt --stack test/eng-nav-away >/dev/null 2>&1
    local child_path="$PARENT_DIR/test-repo-eng-nav-away"
    cd "$child_path"

    # Navigate away to some other directory
    cd /tmp

    # Go back to child worktree
    cd "$child_path"

    # Now navigate to base
    gwt --base

    assert $(pwd) same_as "$parent_path"
    cleanup_test_repo
}

# =============================================================================
# Root Navigation Tests (_gwt_navigate_root / --root / ...)
# =============================================================================

@test '_gwt_navigate_root returns main worktree path from linked worktree' {
    create_test_repo
    # Use pwd -P to resolve symlinks (macOS /var -> /private/var)
    local main_path=$(pwd -P)

    # Create a linked worktree
    gwt test/eng-root-1 >/dev/null 2>&1
    cd "$PARENT_DIR/test-repo-eng-root-1"

    # Navigate to root should return main worktree
    _gwt_navigate_root

    assert $(pwd -P) same_as "$main_path"
    cleanup_test_repo
}

@test '_gwt_navigate_root handles already being in main worktree' {
    create_test_repo
    local main_path=$(pwd)

    # Already in main worktree - should succeed with message
    run _gwt_navigate_root

    assert $state equals 0
    assert "$output" contains "Already in main worktree"
    assert $(pwd) same_as "$main_path"
    cleanup_test_repo
}

@test '_gwt_navigate_root works from deeply nested worktree' {
    create_test_repo
    local main_path=$(pwd -P)

    # Create parent worktree
    gwt test/eng-5501-parent >/dev/null 2>&1
    cd "$PARENT_DIR/test-repo-eng-5501"

    # Create child worktree (stacked) - name will be parent-name + child-suffix
    gwt --stack test/eng-5502-child >/dev/null 2>&1
    cd "$PARENT_DIR/test-repo-eng-5501-eng-5502"

    # Navigate to root from deeply nested should go to main
    _gwt_navigate_root

    assert $(pwd -P) same_as "$main_path"
    cleanup_test_repo
}

@test 'gwt --root navigates to main worktree' {
    create_test_repo
    local main_path=$(pwd -P)

    gwt test/eng-5503-rootflag >/dev/null 2>&1
    cd "$PARENT_DIR/test-repo-eng-5503"

    gwt --root

    assert $(pwd -P) same_as "$main_path"
    cleanup_test_repo
}

@test 'gwt -r is alias for --root' {
    create_test_repo
    local main_path=$(pwd -P)

    gwt test/eng-5504-ralias >/dev/null 2>&1
    cd "$PARENT_DIR/test-repo-eng-5504"

    gwt -r

    assert $(pwd -P) same_as "$main_path"
    cleanup_test_repo
}

@test 'gwt ... navigates to main worktree' {
    create_test_repo
    local main_path=$(pwd -P)

    gwt test/eng-5505-dots >/dev/null 2>&1
    cd "$PARENT_DIR/test-repo-eng-5505"

    gwt ...

    assert $(pwd -P) same_as "$main_path"
    cleanup_test_repo
}

@test 'gwt ... works from deeply nested worktree chain' {
    create_test_repo
    local main_path=$(pwd -P)

    # Create parent worktree
    gwt test/eng-5506-dotsparent >/dev/null 2>&1
    cd "$PARENT_DIR/test-repo-eng-5506"

    # Create child worktree - name will be parent-name + child-suffix
    gwt --stack test/eng-5507-dotschild >/dev/null 2>&1
    cd "$PARENT_DIR/test-repo-eng-5506-eng-5507"

    gwt ...

    assert $(pwd -P) same_as "$main_path"
    cleanup_test_repo
}

@test 'gwt --root shows message when already in main worktree' {
    create_test_repo

    run gwt --root

    assert $state equals 0
    assert "$output" contains "Already in main worktree"
    cleanup_test_repo
}

@test 'gwt ... shows message when already in main worktree' {
    create_test_repo

    run gwt ...

    assert $state equals 0
    assert "$output" contains "Already in main worktree"
    cleanup_test_repo
}

# =============================================================================
# Phase 6: --info Command Tests
# =============================================================================

@test 'gwt --info shows current worktree info' {
    create_test_repo
    local current_branch=$(git branch --show-current)

    run gwt --info

    assert $state equals 0
    assert "$output" contains "$current_branch"
    cleanup_test_repo
}

@test 'gwt -i is alias for --info' {
    create_test_repo

    run gwt -i

    assert $state equals 0
    cleanup_test_repo
}

@test 'gwt --info shows base when tracked' {
    create_test_repo
    git checkout -q -b feature/info-parent

    gwt --stack test/eng-info-1 >/dev/null 2>&1
    cd "$PARENT_DIR/test-repo-eng-info-1"

    run gwt --info

    assert $state equals 0
    assert "$output" contains "feature/info-parent"
    cleanup_test_repo
}

@test 'gwt --info shows not tracked when no base' {
    create_test_repo

    run gwt --info

    assert $state equals 0
    assert "$output" contains "not tracked"
    cleanup_test_repo
}

@test 'gwt --info shows dependents list' {
    create_test_repo
    git checkout -q -b feature/info-parent-dep
    local parent_path=$(pwd)

    # Create two stacked worktrees with distinct names (avoiding suffix collision)
    gwt --stack test/eng-8801-first-child >/dev/null 2>&1
    cd "$parent_path"
    gwt --stack test/eng-8802-second-child >/dev/null 2>&1
    cd "$parent_path"

    run gwt --info

    assert $state equals 0
    assert "$output" contains "eng-8801"
    assert "$output" contains "eng-8802"
    cleanup_test_repo
}

@test 'gwt --info indicates missing base worktree' {
    create_test_repo
    git checkout -q -b feature/info-missing
    local parent_path=$(pwd)

    gwt --stack test/eng-info-missing >/dev/null 2>&1
    cd "$PARENT_DIR/test-repo-eng-info-missing"

    # Overwrite metadata to point to non-existent path
    _gwt_metadata_set "feature/info-missing" "/nonexistent/path"

    run gwt --info

    assert $state equals 0
    assert "$output" contains "missing"
    cleanup_test_repo
}

@test 'gwt --info shows no dependents when none exist' {
    create_test_repo

    run gwt --info

    # Should show info but no dependents section or "no dependents"
    assert $state equals 0
    cleanup_test_repo
}

# =============================================================================
# Phase 7: Enhanced --list Tests
# =============================================================================

@test 'gwt --list shows stack relationships with tree structure' {
    create_test_repo
    git checkout -q -b feature/list-parent
    local parent_path=$(pwd)

    # Create a stacked worktree
    gwt --stack test/eng-9901-list-child >/dev/null 2>&1
    cd "$parent_path"

    run gwt --list

    assert $state equals 0
    # Should show hierarchy indicator for child worktree
    assert "$output" contains "eng-9901"
    assert "$output" contains "└─"
    cleanup_test_repo
}

@test 'gwt --list shows multiple levels of hierarchy' {
    create_test_repo
    git checkout -q -b feature/list-level1
    local level1_path=$(pwd)

    gwt --stack test/eng-9902-level2 >/dev/null 2>&1
    local level2_path="$PARENT_DIR/test-repo-eng-9902"
    cd "$level2_path"

    gwt --stack test/eng-9903-level3 >/dev/null 2>&1
    cd "$level1_path"

    run gwt --list

    assert $state equals 0
    # Should show nested hierarchy
    assert "$output" contains "eng-9902"
    assert "$output" contains "eng-9903"
    cleanup_test_repo
}

@test 'gwt --list works with flat worktrees (no stacking)' {
    create_test_repo

    # Create worktree without stacking
    gwt test/eng-9904-flat >/dev/null 2>&1
    cd "$REPO_DIR"

    run gwt --list

    assert $state equals 0
    # Should show flat worktree without hierarchy indicators
    assert "$output" contains "eng-9904"
    cleanup_test_repo
}

@test 'gwt --list handles orphaned children gracefully' {
    create_test_repo
    git checkout -q -b feature/orphan-parent
    local parent_path=$(pwd)

    gwt --stack test/eng-9905-orphan >/dev/null 2>&1
    cd "$PARENT_DIR/test-repo-eng-9905"

    # Manually corrupt the metadata to simulate orphaned worktree
    _gwt_metadata_set "nonexistent/branch" "/nonexistent/path"
    cd "$REPO_DIR"

    run gwt --list

    # Should still list the worktree even if parent is orphaned
    assert $state equals 0
    assert "$output" contains "eng-9905"
    cleanup_test_repo
}

# =============================================================================
# Phase 8: Dependency-Aware --prune Tests
# =============================================================================

@test '_gwt_get_dependents_count returns correct count' {
    create_test_repo
    git checkout -q -b feature/prune-parent-count
    local parent_path=$(pwd)

    # Create two stacked worktrees
    gwt --stack test/eng-7701-dep1 >/dev/null 2>&1
    cd "$parent_path"
    gwt --stack test/eng-7702-dep2 >/dev/null 2>&1
    cd "$parent_path"

    local count=$(_gwt_get_dependents_count "feature/prune-parent-count")
    assert "$count" same_as "2"
    cleanup_test_repo
}

@test '_gwt_get_dependents_count returns 0 when no dependents' {
    create_test_repo
    git checkout -q -b feature/prune-no-deps

    local count=$(_gwt_get_dependents_count "feature/prune-no-deps")
    assert "$count" same_as "0"
    cleanup_test_repo
}

@test '_gwt_prune_worktree cleans up registry entry' {
    create_test_repo
    git checkout -q -b feature/prune-registry
    local parent_path=$(pwd)

    gwt --stack test/eng-7703-cleanup >/dev/null 2>&1
    cd "$REPO_DIR"

    # Verify registry entry exists
    local reg_before=$(git config "gwt.registry.test-repo-eng-7703.baseBranch")
    assert "$reg_before" same_as "feature/prune-registry"

    # Prune the worktree
    _gwt_prune_worktree "$PARENT_DIR/test-repo-eng-7703"

    # Registry entry should be cleaned up
    local reg_after=$(git config "gwt.registry.test-repo-eng-7703.baseBranch" 2>/dev/null || echo "")
    assert "$reg_after" same_as ""
    cleanup_test_repo
}

@test '_gwt_prune_cascade removes worktree and all dependents' {
    create_test_repo
    git checkout -q -b feature/prune-cascade
    local parent_path=$(pwd)

    gwt --stack test/eng-7704-cascade-child >/dev/null 2>&1
    cd "$REPO_DIR"

    # Both worktrees should exist
    assert "$PARENT_DIR/test-repo-eng-7704" is_dir

    # Cascade prune (non-interactive)
    _gwt_prune_cascade "feature/prune-cascade"

    # Child worktree should be deleted (use ! -d instead of not_is_dir)
    [[ ! -d "$PARENT_DIR/test-repo-eng-7704" ]]
    assert $? equals 0
    cleanup_test_repo
}

# =============================================================================
# Setup Skill Tests (--setup-skill / --setup-ai)
# =============================================================================

@test 'gwt --setup-skill creates skill directory' {
    local test_home=$(mktemp -d)

    HOME="$test_home" run gwt --setup-skill

    assert "$test_home/.claude/skills/gwt" is_dir
    _safe_rm_rf "$test_home"
}

@test 'gwt --setup-skill copies SKILL.md file' {
    local test_home=$(mktemp -d)

    HOME="$test_home" run gwt --setup-skill

    assert "$test_home/.claude/skills/gwt/SKILL.md" is_file
    _safe_rm_rf "$test_home"
}

@test 'gwt --setup-skill file contains skill frontmatter' {
    local test_home=$(mktemp -d)

    HOME="$test_home" gwt --setup-skill >/dev/null 2>&1
    local content=$(cat "$test_home/.claude/skills/gwt/SKILL.md")

    assert "$content" contains "name: gwt"
    _safe_rm_rf "$test_home"
}

@test 'gwt --setup-skill shows success message' {
    local test_home=$(mktemp -d)

    HOME="$test_home" run gwt --setup-skill

    assert $state equals 0
    assert "$output" contains "Skill installed"
    _safe_rm_rf "$test_home"
}

@test 'gwt --setup-skill shows usage hint' {
    local test_home=$(mktemp -d)

    HOME="$test_home" run gwt --setup-skill

    assert "$output" contains "/gwt"
    _safe_rm_rf "$test_home"
}

@test 'gwt --setup-ai is alias for --setup-skill' {
    local test_home=$(mktemp -d)

    HOME="$test_home" run gwt --setup-ai

    assert $state equals 0
    assert "$test_home/.claude/skills/gwt/SKILL.md" is_file
    _safe_rm_rf "$test_home"
}

@test 'gwt --setup-skill overwrites existing skill' {
    local test_home=$(mktemp -d)
    mkdir -p "$test_home/.claude/skills/gwt"
    echo "old content" > "$test_home/.claude/skills/gwt/SKILL.md"

    HOME="$test_home" run gwt --setup-skill

    assert $state equals 0
    local content=$(cat "$test_home/.claude/skills/gwt/SKILL.md")
    assert "$content" contains "name: gwt"
    assert "$content" does_not_contain "old content"
    _safe_rm_rf "$test_home"
}

@test 'gwt --setup-skill shows updated message when overwriting' {
    local test_home=$(mktemp -d)
    mkdir -p "$test_home/.claude/skills/gwt"
    echo "old content" > "$test_home/.claude/skills/gwt/SKILL.md"

    HOME="$test_home" run gwt --setup-skill

    assert "$output" contains "updated"
    _safe_rm_rf "$test_home"
}

@test 'gwt --setup-skill works outside git repo' {
    local test_home=$(mktemp -d)
    local test_dir=$(mktemp -d)
    mkdir -p "$test_dir/not-a-repo"
    cd "$test_dir/not-a-repo"

    HOME="$test_home" run gwt --setup-skill

    assert $state equals 0
    _safe_rm_rf "$test_home"
    _safe_rm_rf "$test_dir"
}

@test 'gwt --help mentions --setup-skill' {
    run gwt --help

    assert "$output" contains "setup-skill"
}
